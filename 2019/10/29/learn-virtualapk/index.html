<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"libill.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="什么是插件化？ 插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解VirtualApk插件化">
<meta property="og:url" content="https://libill.github.io/2019/10/29/learn-virtualapk/index.html">
<meta property="og:site_name" content="libill的博客">
<meta property="og:description" content="什么是插件化？ 插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的">
<meta property="og:locale">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity_Action.png">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity.png">
<meta property="article:published_time" content="2019-10-29T06:37:00.000Z">
<meta property="article:modified_time" content="2021-10-08T07:45:02.561Z">
<meta property="article:author" content="libill">
<meta property="article:tag" content="插件化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png">

<link rel="canonical" href="https://libill.github.io/2019/10/29/learn-virtualapk/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>深入理解VirtualApk插件化 | libill的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">libill的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2019/10/29/learn-virtualapk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解VirtualApk插件化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-29 14:37:00" itemprop="dateCreated datePublished" datetime="2019-10-29T14:37:00+08:00">2019-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-08 15:45:02" itemprop="dateModified" datetime="2021-10-08T15:45:02+08:00">2021-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>什么是插件化？</p>
<p>插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的包名和版本号，包名可以区别宿主和各个插件，版本号可用于宿主和插件的升级。</p>
<p>简单介绍下VirtualAPK</p>
<p>VirtualAPK对插件没有额外的约束，原生的apk即可作为插件。插件工程编译生成apk后，即可通过宿主App加载，每个插件apk被加载后，都会在宿主中创建一个单独的LoadedPlugin对象。如下图所示，通过这些LoadedPlugin对象，VirtualAPK就可以管理插件并赋予插件新的意义，使其可以像手机中安装过的App一样运行。</p>
<h3 id="一、从代码入口分析"><a href="#一、从代码入口分析" class="headerlink" title="一、从代码入口分析"></a>一、从代码入口分析</h3><p>代码分析基于0.9.8版本</p>
<pre><code>compile &#39;com.didi.virtualapk:core:0.9.8&#39;
</code></pre>
<p>VirtualApk初始化插件引擎需要在Application的attachBaseContext进行</p>
<pre><code>public class VAApplication extends Application &#123;

    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        PluginManager.getInstance(base).init();
    &#125;

&#125;
</code></pre>
<p>getInstalce方法用单例设计模式创建PluginManager对象，使用了synchronized关键字同步锁</p>
<pre><code>public static PluginManager getInstance(Context base) &#123;
    if (sInstance == null) &#123;
        synchronized (PluginManager.class) &#123;
            if (sInstance == null) &#123;
                sInstance = createInstance(base);
            &#125;
        &#125;
    &#125;

    return sInstance;
&#125;
</code></pre>
<p>创建PluginManager对象后，接着会调用hookCurrentProcess方法</p>
<pre><code>protected void hookCurrentProcess() &#123;
    hookInstrumentationAndHandler();
    hookSystemServices();
    hookDataBindingUtil();
&#125;
</code></pre>
<p>到这里可以知道，hook了Instrumentation、Handler、SystemServices、DataBindingUtil。下面逐个分析下这四个hook流程，这里分析流程的目的是要了解hook是怎么回事，hook了是要干嘛呢。</p>
<h3 id="二、hookInstrumentationAndHandler"><a href="#二、hookInstrumentationAndHandler" class="headerlink" title="二、hookInstrumentationAndHandler"></a>二、hookInstrumentationAndHandler</h3><p>先看看hookInstrumentationAndHandler的代码</p>
<pre><code>protected void hookInstrumentationAndHandler() &#123;
    try &#123;
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Instrumentation baseInstrumentation = activityThread.getInstrumentation();

        final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);
        
        Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);
        Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
        Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);
        this.mInstrumentation = instrumentation;
        Log.d(TAG, &quot;hookInstrumentationAndHandler succeed : &quot; + mInstrumentation);
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>第一行ActivityThread activityThread = ActivityThread.currentActivityThread();这里会不会让你想起什么来，ActivityThread是一个@hide类，为什么可以直接使用@hide类呢？可以按点击去试试看，会跳到AndroidStub模块下的ActivityThread。AndroidStub定义了许多路径一样的类但是里面都是实现抛出RuntimeException.为了尽量避免使用反射浪费性能，使用了AndroidStub模块来欺骗编译器。欺骗编译器需要查看Android framework层源码，定义和原码中一摸一样的方法，实现抛出RuntimeException。CoreLibrary使用provided依赖AndroidStub，provided依赖是不打包依赖包，而是运行时提供，所以成功欺骗了编辑器，用来提高了性能。</p>
<pre><code>public final class ActivityThread &#123;

    public static ActivityThread currentActivityThread() &#123;
        throw new RuntimeException(&quot;Stub!&quot;);
    &#125;
    ...
&#125;
</code></pre>
<p>CoreLibrary使用provided依赖AndroidStub</p>
<pre><code>final String projectAndroidStub = &#39;:AndroidStub&#39;
dependencies &#123;
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    provided project(projectAndroidStub)
&#125;
</code></pre>
<p>现在回到hook instrumentation上，使用了Reflector反射器直接把framework层的ActivityThread类下mInstrumentation变量变成了VAInstrumentation，使得VAInstrumentation起到了代理作用。</p>
<pre><code>final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);
Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);
</code></pre>
<p>代理的目的就是先让VAInstrumentation处理自己的逻辑，处理完后再给framework层的Instrumentation处理，以实现达到欺骗系统的作用，校验的是宿主占坑Activity，启动插件中的Activity。</p>
<pre><code>public class VAInstrumentation extends Instrumentation implements Handler.Callback &#123;
...
protected Instrumentation mBase;

@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123;
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
&#125;

protected void injectIntent(Intent intent) &#123;
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) &#123;
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    &#125;
&#125;
...
&#125;
</code></pre>
<p>现在来看看hook Handler,</p>
<pre><code>Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);
</code></pre>
<p>看看ActivityThread源码下getHandler()是什么?原来是H类。</p>
<pre><code>public final class ActivityThread extends ClientTransactionHandler &#123;
    ...
    final H mH = new H();
    final Handler getHandler() &#123;
        return mH;
    &#125;
    ...
&#125;
</code></pre>
<p>那为什么可以直接把H类的mCallback直接替换成功VAInstrumentation实现的Handler.Callback不会引起其他问题，导致无法执行H类的handleMessage呢？看看Handler源码就知道了。new H()的时候mCallback为null，使用代理VAInstrumentation后mCallback.handleMessage(msg)会一直返回false，会继续执行handleMessage方法。起到了代理H类的效果，先执行VAInstrumentation的handleMessage,再执行H类的handleMessage。</p>
<pre><code>public class Handler &#123;
    ...
    public Handler() &#123;
        this(null, false);
    &#125;

    public Handler(Callback callback, boolean async) &#123;
        ...
        mCallback = callback;
        mAsynchronous = async;
    &#125;

    public void dispatchMessage(Message msg) &#123;
        if (msg.callback != null) &#123;
            handleCallback(msg);
        &#125; else &#123;
            if (mCallback != null) &#123;
                if (mCallback.handleMessage(msg)) &#123;
                    return;
                &#125;
            &#125;
            handleMessage(msg);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png"></p>
<h3 id="三、hookSystemServices"><a href="#三、hookSystemServices" class="headerlink" title="三、hookSystemServices"></a>三、hookSystemServices</h3><p>hook SystemServices的时候，先从ActivityManager.class或ActivityManagerNative.class中反射获取Singleton<IActivityManager>对象，再使用ActivityManagerProxy动态代理动态代理获取一个 IActivityManager.</p>
<pre><code>protected void hookSystemServices() &#123;
    try &#123;
        Singleton&lt;IActivityManager&gt; defaultSingleton;

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;
            defaultSingleton = Reflector.on(ActivityManager.class).field(&quot;IActivityManagerSingleton&quot;).get();
        &#125; else &#123;
            defaultSingleton = Reflector.on(ActivityManagerNative.class).field(&quot;gDefault&quot;).get();
        &#125;
        IActivityManager origin = defaultSingleton.get();
        IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] &#123; IActivityManager.class &#125;,
            createActivityManagerProxy(origin));

        // Hook IActivityManager from ActivityManagerNative
        Reflector.with(defaultSingleton).field(&quot;mInstance&quot;).set(activityManagerProxy);

        if (defaultSingleton.get() == activityManagerProxy) &#123;
            this.mActivityManager = activityManagerProxy;
            Log.d(TAG, &quot;hookSystemServices succeed : &quot; + mActivityManager);
        &#125;
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>ActivityManager.class下的IActivityManagerSingleton</p>
<pre><code>public class ActivityManager &#123;
    ...
    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
            new Singleton&lt;IActivityManager&gt;() &#123;
                @Override
                protected IActivityManager create() &#123;
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                &#125;
            &#125;;
    &#125;
    ...
&#125;
</code></pre>
<p>Reflector.with(defaultSingleton).field(“mInstance”).set(activityManagerProxy);这里的mInstance其实是Singleton<T>类的mInstance变量。</p>
<pre><code>public abstract class Singleton&lt;T&gt; &#123;
    private T mInstance;

    protected abstract T create();

    public final T get() &#123;
        synchronized (this) &#123;
            if (mInstance == null) &#123;
                mInstance = create();
            &#125;
            return mInstance;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="三、hook-DataBindingUtil"><a href="#三、hook-DataBindingUtil" class="headerlink" title="三、hook DataBindingUtil"></a>三、hook DataBindingUtil</h3><p>分析完上面2个原理，到这里应该比较清晰hook是什么回事了，就是在执行framework层代码之前，先执行Proxy代理的代码，来实现一些意想不到的效果。hook DataBindingUtil可以自己看看代码分析下。</p>
<pre><code>protected void hookDataBindingUtil() &#123;
    Reflector.QuietReflector reflector = Reflector.QuietReflector.on(&quot;android.databinding.DataBindingUtil&quot;).field(&quot;sMapper&quot;);
    Object old = reflector.get();
    if (old != null) &#123;
        try &#123;
            Callback callback = Reflector.on(&quot;android.databinding.DataBinderMapperProxy&quot;).constructor().newInstance();
            reflector.set(callback);
            addCallback(callback);
            Log.d(TAG, &quot;hookDataBindingUtil succeed : &quot; + callback);
        &#125; catch (Reflector.ReflectedException e) &#123;
            Log.w(TAG, e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="四、支持插件中的Activity"><a href="#四、支持插件中的Activity" class="headerlink" title="四、支持插件中的Activity"></a>四、支持插件中的Activity</h3><p>这里需要了解Activity的启动流程，如果你还没有了解可以点击这里。前面我们了解了hook Instrumentation,看看VAInstrumentation到底做了什么。启动Activity时会执行execStartActivity，而在执行execStartActivity之前做了injectIntent，是为了绕过系统校验是否在宿主的AndroidManifest.xml中注册过插件中的Activity。也就是要达到插件中的Activity不用在宿主中注册就可以启动。</p>
<pre><code>@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123;
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
&#125;

protected void injectIntent(Intent intent) &#123;
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) &#123;
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    &#125;
&#125;
</code></pre>
<p>transformIntentToExplicitAsNeeded作用是把隐式启动的Activity转化为显式启动。下图可以知道把Intent { act=com.didi.virtualapk.plugin.BookManagerActivity }转化为显式Intent { act=com.didi.virtualapk.plugin.BookManagerActivity cmp=com.didi.virtualapk.demo/.aidl.BookManagerActivity }，ComponentName由null变成包含BookManagerActivity数据的ComponentName。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity_Action.png"></p>
<p>markIntentIfNeeded其实就是记录了下插件的信息包括isPlugin、插件package、要启动的插件Activity类，记录的目的是绕过系统校验后，再把这些信息取出来，启动真正要启动的插件Activity。</p>
<pre><code>public void markIntentIfNeeded(Intent intent) &#123;
    if (intent.getComponent() == null) &#123;
        return;
    &#125;

    String targetPackageName = intent.getComponent().getPackageName();
    String targetClassName = intent.getComponent().getClassName();
    // search map and return specific launchmode stub activity
    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123;
        intent.putExtra(Constants.KEY_IS_PLUGIN, true);
        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);
        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);
        dispatchStubActivity(intent);
    &#125;
&#125;
</code></pre>
<p>这里要看看dispatchStubActivity把targetActivity替换成stubActivity的过程。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity.png"></p>
<p>图中可以看到stubActivity是com.didi.virtualapk.core.A$1，这是CoreLibrary/src/main/AndroidManifest.xml下提前注册占坑Activity。包含了四种启动模式，不同的启动模式取不同的占坑Activity，达到支持插件Activity的四种启动模式。</p>
<pre><code>&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$1&quot; android:launchMode=&quot;standard&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$2&quot; android:launchMode=&quot;standard&quot;
    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$1&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$2&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$3&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$4&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$5&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$6&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$7&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$8&quot; android:launchMode=&quot;singleTop&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$1&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$2&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$3&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$4&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$5&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$6&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$7&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$8&quot; android:launchMode=&quot;singleTask&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$1&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$2&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$3&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$4&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$5&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$6&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$7&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$8&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
</code></pre>
<p>如果想了解如何取对应设计模式的占坑，可以查看StubActivityInfo类，如取值stubActivity为com.didi.virtualapk.core.A$1</p>
<pre><code>public static final String STUB_ACTIVITY_STANDARD = &quot;%s.A$%d&quot;;
stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);
</code></pre>
<p>injectIntent绕过校验后，会执行newActivity,在classloader加载占坑类com.didi.virtualapk.core.A$1时，由于只是占坑，不存在这个类，会走ClassNotFoundException异常逻辑。</p>
<pre><code>@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;
    try &#123;
        cl.loadClass(className);
        Log.i(TAG, String.format(&quot;newActivity[%s]&quot;, className));
        
    &#125; catch (ClassNotFoundException e) &#123;
        ComponentName component = PluginUtil.getComponent(intent);
        
        if (component == null) &#123;
            return newActivity(mBase.newActivity(cl, className, intent));
        &#125;

        String targetClassName = component.getClassName();
        Log.i(TAG, String.format(&quot;newActivity[%s : %s/%s]&quot;, className, component.getPackageName(), targetClassName));

        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(component);

        if (plugin == null) &#123;
            // Not found then goto stub activity.
            boolean debuggable = false;
            try &#123;
                Context context = this.mPluginManager.getHostContext();
                debuggable = (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;
            &#125; catch (Throwable ex) &#123;
    
            &#125;

            if (debuggable) &#123;
                throw new ActivityNotFoundException(&quot;error intent: &quot; + intent.toURI());
            &#125;
            
            Log.i(TAG, &quot;Not found. starting the stub activity: &quot; + StubActivity.class);
            return newActivity(mBase.newActivity(cl, StubActivity.class.getName(), intent));
        &#125;
        
        Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
        activity.setIntent(intent);

        // for 4.1+
        Reflector.QuietReflector.with(activity).field(&quot;mResources&quot;).set(plugin.getResources());

        return newActivity(activity);
    &#125;

    return newActivity(mBase.newActivity(cl, className, intent));
&#125;
</code></pre>
<p>通过this.mPluginManager.getLoadedPlugin(component)获取已经加载的插件，并重新设置了恢复了要启动的插件Activity。就这样callActivityOnCreate的时候也是调用要启动的插件Activity。</p>
<pre><code>@Override
public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;
    injectActivity(activity);
    mBase.callActivityOnCreate(activity, icicle);
&#125;
</code></pre>
<h3 id="五、支持插件中的Service"><a href="#五、支持插件中的Service" class="headerlink" title="五、支持插件中的Service"></a>五、支持插件中的Service</h3><p>前面已经了解了hookSystemServices的过程，是使用了动态代理生成代理类。</p>
<pre><code>IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] &#123; IActivityManager.class &#125;,
    createActivityManagerProxy(origin));
</code></pre>
<p>再看看createActivityManagerProxy做了什么</p>
<pre><code>protected ActivityManagerProxy createActivityManagerProxy(IActivityManager origin) throws Exception &#123;
    return new ActivityManagerProxy(this, origin);
&#125;
</code></pre>
<p>既然用了动态代理，那就看看ActivityManagerProxy的invoke方法</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    if (&quot;startService&quot;.equals(method.getName())) &#123;
        try &#123;
            return startService(proxy, method, args);
        &#125; catch (Throwable e) &#123;
            Log.e(TAG, &quot;Start service error&quot;, e);
        &#125;
    &#125; else if (&quot;stopService&quot;.equals(method.getName())) &#123;
        try &#123;
            return stopService(proxy, method, args);
        &#125; catch (Throwable e) &#123;
            Log.e(TAG, &quot;Stop Service error&quot;, e);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>在执行Service生命周期等关键方法时都做了相应的代理处理，看看startService</p>
<pre><code>protected Object startService(Object proxy, Method method, Object[] args) throws Throwable &#123;
    IApplicationThread appThread = (IApplicationThread) args[0];
    Intent target = (Intent) args[1];
    ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0);
    if (null == resolveInfo || null == resolveInfo.serviceInfo) &#123;
        // is host service
        return method.invoke(this.mActivityManager, args);
    &#125;

    return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);
&#125;
</code></pre>
<p>resolveService判断是不是宿主工程的Service，宿主Service走原来的逻辑，插件Service就走startDelegateServiceForTarget</p>
<pre><code>public ResolveInfo resolveService(Intent intent, int flags) &#123;
    for (LoadedPlugin plugin : this.mPlugins.values()) &#123;
        ResolveInfo resolveInfo = plugin.resolveService(intent, flags);
        if (null != resolveInfo) &#123;
            return resolveInfo;
        &#125;
    &#125;

    return null;
&#125;
</code></pre>
<p>startDelegateServiceForTarget里面执行wrapperTargetIntent，</p>
<pre><code>protected ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123;
    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);
    return mPluginManager.getHostContext().startService(wrapperIntent);
&#125;
</code></pre>
<p>关键点local ? LocalService.class : RemoteService.class，明确了需要哪个Service做代理类。</p>
<pre><code>protected Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123;
    // fill in service with ComponentName
    target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name));
    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();

    // start delegate service to run plugin service inside
    boolean local = PluginUtil.isLocalService(serviceInfo);
    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;
    Intent intent = new Intent();
    intent.setClass(mPluginManager.getHostContext(), delegate);
    intent.putExtra(RemoteService.EXTRA_TARGET, target);
    intent.putExtra(RemoteService.EXTRA_COMMAND, command);
    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);
    if (extras != null) &#123;
        intent.putExtras(extras);
    &#125;

    return intent;
&#125;
</code></pre>
<p>RemoteService继承了LocalService，RemoteService作用是loadPlugin，其他工作交给LocalService。这样做也合理，如果是插件的交给RemoteService来loadPlugin，省下的逻辑都是相同的交给LocalService处理就可以了。</p>
<pre><code>public int onStartCommand(Intent intent, int flags, int startId) &#123;
    if (intent == null) &#123;
        return super.onStartCommand(intent, flags, startId);
    &#125;

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    if (target != null) &#123;
        String pluginLocation = intent.getStringExtra(EXTRA_PLUGIN_LOCATION);
        ComponentName component = target.getComponent();
        LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(component);
        if (plugin == null &amp;&amp; pluginLocation != null) &#123;
            try &#123;
                PluginManager.getInstance(this).loadPlugin(new File(pluginLocation));
            &#125; catch (Exception e) &#123;
                Log.w(TAG, e);
            &#125;
        &#125;
    &#125;

    return super.onStartCommand(intent, flags, startId);
&#125;
</code></pre>
<p>LocalService按照service的启动流程，loadClass先加载service，反射调用attach，在调用onCreate方法，rememberService记录attach后的service,再调用service.onStartCommand执行命令。如果是启动了的直接调用onStartCommand。</p>
<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) &#123;
    if (null == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) &#123;
        return START_STICKY;
    &#125;

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    int command = intent.getIntExtra(EXTRA_COMMAND, 0);
    if (null == target || command &lt;= 0) &#123;
        return START_STICKY;
    &#125;

    ComponentName component = target.getComponent();
    LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component);
    
    if (plugin == null) &#123;
        Log.w(TAG, &quot;Error target: &quot; + target.toURI());
        return START_STICKY;
    &#125;
    // ClassNotFoundException when unmarshalling in Android 5.1
    target.setExtrasClassLoader(plugin.getClassLoader());
    switch (command) &#123;
        case EXTRA_COMMAND_START_SERVICE: &#123;
            ActivityThread mainThread = ActivityThread.currentActivityThread();
            IApplicationThread appThread = mainThread.getApplicationThread();
            Service service;

            if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123;
                service = this.mPluginManager.getComponentsHandler().getService(component);
            &#125; else &#123;
                try &#123;
                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();

                    Application app = plugin.getApplication();
                    IBinder token = appThread.asBinder();
                    Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);
                    IActivityManager am = mPluginManager.getActivityManager();

                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);
                    service.onCreate();
                    this.mPluginManager.getComponentsHandler().rememberService(component, service);
                &#125; catch (Throwable t) &#123;
                    return START_STICKY;
                &#125;
            &#125;

            service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());
            break;
        &#125;
        ...
    &#125;

    return START_STICKY;
&#125;
</code></pre>
<p>TODO：分析动态代理思想</p>
<h3 id="六、支持插件中的BroadcastReceiver"><a href="#六、支持插件中的BroadcastReceiver" class="headerlink" title="六、支持插件中的BroadcastReceiver"></a>六、支持插件中的BroadcastReceiver</h3><p>思路是动态注册广播，将静态注册的广播转变为动态注册，将插件中静态注册的receiver使用mHostContext重新注册一遍。具体代码可以在LoadedPlugin构造方法查看。</p>
<pre><code>public LoadedPlugin(PluginManager pluginManager, Context context, File apk) throws Exception &#123;
    ...

    // Register broadcast receivers dynamically
    Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();
    for (PackageParser.Activity receiver : this.mPackage.receivers) &#123;
        receivers.put(receiver.getComponentName(), receiver.info);

        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());
        for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123;
            this.mHostContext.registerReceiver(br, aii);
        &#125;
    &#125;
    this.mReceiverInfos = Collections.unmodifiableMap(receivers);
    this.mPackageInfo.receivers = receivers.values().toArray(new ActivityInfo[receivers.size()]);

    // try to invoke plugin&#39;s application
    invokeApplication();
&#125;
</code></pre>
<p>再看看查询所有的receivers，先对比ComponentName是否相同，component为空时再用intent等去匹配。</p>
<pre><code>public List&lt;ResolveInfo&gt; queryBroadcastReceivers(Intent intent, int flags) &#123;
    ComponentName component = intent.getComponent();
    List&lt;ResolveInfo&gt; resolveInfos = new ArrayList&lt;ResolveInfo&gt;();
    ContentResolver resolver = this.mPluginContext.getContentResolver();

    for (PackageParser.Activity receiver : this.mPackage.receivers) &#123;
        if (receiver.getComponentName().equals(component)) &#123;
            ResolveInfo resolveInfo = new ResolveInfo();
            resolveInfo.activityInfo = receiver.info;
            resolveInfos.add(resolveInfo);
        &#125; else if (component == null) &#123;
            // only match implicit intent
            for (PackageParser.ActivityIntentInfo intentInfo : receiver.intents) &#123;
                if (intentInfo.match(resolver, intent, true, TAG) &gt;= 0) &#123;
                    ResolveInfo resolveInfo = new ResolveInfo();
                    resolveInfo.activityInfo = receiver.info;
                    resolveInfos.add(resolveInfo);
                    break;
                &#125;
            &#125;
        &#125;
    &#125;

    return resolveInfos;
&#125;
</code></pre>
<h3 id="七、支持插件中的ContentProvider"><a href="#七、支持插件中的ContentProvider" class="headerlink" title="七、支持插件中的ContentProvider"></a>七、支持插件中的ContentProvider</h3><p>先看一下插件化是如何使用ContentProvider的，获取插件LoadedPlugin后，通过PluginContentResolver的wrapperUri转化Uri为后续支持读取的Uri。</p>
<pre><code>// test ContentProvider
Uri bookUri = Uri.parse(&quot;content://com.didi.virtualapk.demo.book.provider/book&quot;);
LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(pkg);
bookUri = PluginContentResolver.wrapperUri(plugin, bookUri);

Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);
if (bookCursor != null) &#123;
    while (bookCursor.moveToNext()) &#123;
        int bookId = bookCursor.getInt(0);
        String bookName = bookCursor.getString(1);
        Log.d(&quot;ryg&quot;, &quot;query book:&quot; + bookId + &quot;, &quot; + bookName);
    &#125;
    bookCursor.close();
&#125;
</code></pre>
<p>是用wrapperUri转化下Uri后就可以正常读取ContentProvider的数据了。这里使用到了RemoteContentProvider，这个转化其实就是后面会使用到RemoteContentProvider。</p>
<pre><code>public static Uri wrapperUri(LoadedPlugin loadedPlugin, Uri pluginUri) &#123;
    String pkg = loadedPlugin.getPackageName();
    String pluginUriString = Uri.encode(pluginUri.toString());
    StringBuilder builder = new StringBuilder(RemoteContentProvider.getUri(loadedPlugin.getHostContext()));
    builder.append(&quot;/?plugin=&quot; + loadedPlugin.getLocation());
    builder.append(&quot;&amp;pkg=&quot; + pkg);
    builder.append(&quot;&amp;uri=&quot; + pluginUriString);
    Uri wrapperUri = Uri.parse(builder.toString());
    return wrapperUri;
&#125;
</code></pre>
<p>wrapperUri会拼接成</p>
<pre><code>content://com.libill.virtualapk.VirtualAPK.Provider/?plugin=/storage/emulated/0/Test.apk&amp;pkg=com.didi.virtualapk.demo&amp;uri=content%3A%2F%2Fcom.didi.virtualapk.demo.book.provider%2Fbook
</code></pre>
<p>我们先看看pluginManager.loadPlugin(apk)时做了一些解释数据，并缓存起来。</p>
<pre><code>// Cache providers
Map&lt;String, ProviderInfo&gt; providers = new HashMap&lt;String, ProviderInfo&gt;();
Map&lt;ComponentName, ProviderInfo&gt; providerInfos = new HashMap&lt;ComponentName, ProviderInfo&gt;();
for (PackageParser.Provider provider : this.mPackage.providers) &#123;
    providers.put(provider.info.authority, provider.info);
    providerInfos.put(provider.getComponentName(), provider.info);
&#125;
this.mProviders = Collections.unmodifiableMap(providers);
this.mProviderInfos = Collections.unmodifiableMap(providerInfos);
this.mPackageInfo.providers = providerInfos.values().toArray(new ProviderInfo[providerInfos.size()]);
</code></pre>
<p>当使用getContentResolver的query时，会通过IPC通信，调用acquireProvider获取IContentProvider的binder对象。而PluginContentResolver对acquireProvider等多个方法做了代理。</p>
<pre><code>@Override
protected IContentProvider acquireProvider(Context context, String auth) &#123;
    if (mPluginManager.resolveContentProvider(auth, 0) != null) &#123;
        return mPluginManager.getIContentProvider();
    &#125;
    return super.acquireProvider(context, auth);
&#125;
</code></pre>
<p>在getIContentProvider方法，做了hook IContentProvider动作。</p>
<pre><code>public synchronized IContentProvider getIContentProvider() &#123;
    if (mIContentProvider == null) &#123;
        hookIContentProviderAsNeeded();
    &#125;

    return mIContentProvider;
&#125;
</code></pre>
<p>使用了反射器对mProviderMap反射操作，获取mProviderMap来能获取到占坑的 Provider。对authority、mProvider做了setAccessible(true)，最终IContentProviderProxy.newInstance生成IContentProviderProxy对象。这里还使用了RemoteContentProvider包装Uri。</p>
<pre><code>protected void hookIContentProviderAsNeeded() &#123;
    Uri uri = Uri.parse(RemoteContentProvider.getUri(mContext));
    mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null);
    try &#123;
        Field authority = null;
        Field provider = null;
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Map providerMap = Reflector.with(activityThread).field(&quot;mProviderMap&quot;).get();
        Iterator iter = providerMap.entrySet().iterator();
        while (iter.hasNext()) &#123;
            Map.Entry entry = (Map.Entry) iter.next();
            Object key = entry.getKey();
            Object val = entry.getValue();
            String auth;
            if (key instanceof String) &#123;
                auth = (String) key;
            &#125; else &#123;
                if (authority == null) &#123;
                    authority = key.getClass().getDeclaredField(&quot;authority&quot;);
                    authority.setAccessible(true);
                &#125;
                auth = (String) authority.get(key);
            &#125;
            if (auth.equals(RemoteContentProvider.getAuthority(mContext))) &#123;
                if (provider == null) &#123;
                    provider = val.getClass().getDeclaredField(&quot;mProvider&quot;);
                    provider.setAccessible(true);
                &#125;
                IContentProvider rawProvider = (IContentProvider) provider.get(val);
                IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider);
                mIContentProvider = proxy;
                Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider);
                break;
            &#125;
        &#125;
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>IContentProvider使用了动态代理方式</p>
<pre><code>public static IContentProvider newInstance(Context context, IContentProvider iContentProvider) &#123;
    return (IContentProvider) Proxy.newProxyInstance(iContentProvider.getClass().getClassLoader(),
            new Class[] &#123; IContentProvider.class &#125;, new IContentProviderProxy(context, iContentProvider));
&#125;
</code></pre>
<p>看看invoke方法，使用wrapperUri后直接调用method.invoke</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    Log.v(TAG, method.toGenericString() + &quot; : &quot; + Arrays.toString(args));
    wrapperUri(method, args);

    try &#123;
        return method.invoke(mBase, args);
    &#125; catch (InvocationTargetException e) &#123;
        throw e.getTargetException();
    &#125;
&#125;
</code></pre>
<p>在RemoteContentProvider的getContentProvider可以看到加载和使用插件的ContentProvider。</p>
<pre><code>private ContentProvider getContentProvider(final Uri uri) &#123;
    final PluginManager pluginManager = PluginManager.getInstance(getContext());
    Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI));
    final String auth = pluginUri.getAuthority();
    ContentProvider cachedProvider = sCachedProviders.get(auth);
    if (cachedProvider != null) &#123;
        return cachedProvider;
    &#125;

    synchronized (sCachedProviders) &#123;
        LoadedPlugin plugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
        if (plugin == null) &#123;
            try &#123;
                pluginManager.loadPlugin(new File(uri.getQueryParameter(KEY_PLUGIN)));
            &#125; catch (Exception e) &#123;
                Log.w(TAG, e);
            &#125;
        &#125;

        final ProviderInfo providerInfo = pluginManager.resolveContentProvider(auth, 0);
        if (providerInfo != null) &#123;
            RunUtil.runOnUiThread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    try &#123;
                        LoadedPlugin loadedPlugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
                        ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance();
                        contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);
                        sCachedProviders.put(auth, contentProvider);
                    &#125; catch (Exception e) &#123;
                        Log.w(TAG, e);
                    &#125;
                &#125;
            &#125;, true);
            return sCachedProviders.get(auth);
        &#125;
    &#125;

    return null;
&#125;
</code></pre>
<h3 id="八、支持插件中的Resources"><a href="#八、支持插件中的Resources" class="headerlink" title="八、支持插件中的Resources"></a>八、支持插件中的Resources</h3><p>资源的加载入口时加载插件时生成LoadedPlugin对象，这时开始加载资源。</p>
<pre><code>this.mResources = createResources(context, getPackageName(), apk);
</code></pre>
<p>Constants.COMBINE_RESOURCES一直为true，直接进入ResourcesManager.createResources</p>
<pre><code>protected Resources createResources(Context context, String packageName, File apk) throws Exception &#123;
    if (Constants.COMBINE_RESOURCES) &#123;
        return ResourcesManager.createResources(context, packageName, apk);
    &#125; else &#123;
        Resources hostResources = context.getResources();
        AssetManager assetManager = createAssetManager(context, apk);
        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    &#125;
&#125;
</code></pre>
<p>createResources加载资源后，用hook Resources一遍</p>
<pre><code>public static synchronized Resources createResources(Context hostContext, String packageName, File apk) throws Exception &#123;
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;
        return createResourcesForN(hostContext, packageName, apk);
    &#125;
    
    Resources resources = ResourcesManager.createResourcesSimple(hostContext, apk.getAbsolutePath());
    ResourcesManager.hookResources(hostContext, resources);
    return resources;
&#125;
</code></pre>
<p>createResourcesForN是兼容N</p>
<pre><code>@TargetApi(Build.VERSION_CODES.N)
private static Resources createResourcesForN(Context context, String packageName, File apk) throws Exception &#123;
    long startTime = System.currentTimeMillis();
    String newAssetPath = apk.getAbsolutePath();
    ApplicationInfo info = context.getApplicationInfo();
    String baseResDir = info.publicSourceDir;
    
    info.splitSourceDirs = append(info.splitSourceDirs, newAssetPath);
    LoadedApk loadedApk = Reflector.with(context).field(&quot;mPackageInfo&quot;).get();

    Reflector rLoadedApk = Reflector.with(loadedApk).field(&quot;mSplitResDirs&quot;);
    String[] splitResDirs = rLoadedApk.get();
    rLoadedApk.set(append(splitResDirs, newAssetPath));

    final android.app.ResourcesManager resourcesManager = android.app.ResourcesManager.getInstance();
    ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; originalMap = Reflector.with(resourcesManager).field(&quot;mResourceImpls&quot;).get();

    synchronized (resourcesManager) &#123;
        HashMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; resolvedMap = new HashMap&lt;&gt;();

        if (Build.VERSION.SDK_INT &gt;= 28
            || (Build.VERSION.SDK_INT == 27 &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != 0)) &#123; // P Preview
            ResourcesManagerCompatForP.resolveResourcesImplMap(originalMap, resolvedMap, context, loadedApk);

        &#125; else &#123;
            ResourcesManagerCompatForN.resolveResourcesImplMap(originalMap, resolvedMap, baseResDir, newAssetPath);
        &#125;

        originalMap.clear();
        originalMap.putAll(resolvedMap);
    &#125;

    android.app.ResourcesManager.getInstance().appendLibAssetForMainAssetPath(baseResDir, packageName + &quot;.vastub&quot;);

    Resources newResources = context.getResources();

    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : PluginManager.getInstance(context).getAllLoadedPlugins()) &#123;
        plugin.updateResources(newResources);
    &#125;

    Log.d(TAG, &quot;createResourcesForN cost time: +&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);
    return newResources;
&#125;
</code></pre>
<p>按照系统版本、厂家来兼容</p>
<pre><code>private static Resources createResourcesSimple(Context hostContext, String apk) throws Exception &#123;
    Resources hostResources = hostContext.getResources();
    Resources newResources = null;
    AssetManager assetManager;
    Reflector reflector = Reflector.on(AssetManager.class).method(&quot;addAssetPath&quot;, String.class);
    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;
        assetManager = AssetManager.class.newInstance();
        reflector.bind(assetManager);
        final int cookie1 = reflector.call(hostContext.getApplicationInfo().sourceDir);;
        if (cookie1 == 0) &#123;
            throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + hostContext.getApplicationInfo().sourceDir);
        &#125;
    &#125; else &#123;
        assetManager = hostResources.getAssets();
        reflector.bind(assetManager);
    &#125;
    final int cookie2 = reflector.call(apk);
    if (cookie2 == 0) &#123;
        throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + apk);
    &#125;
    List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins();
    for (LoadedPlugin plugin : pluginList) &#123;
        final int cookie3 = reflector.call(plugin.getLocation());
        if (cookie3 == 0) &#123;
            throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + plugin.getLocation());
        &#125;
    &#125;
    if (isMiUi(hostResources)) &#123;
        newResources = MiUiResourcesCompat.createResources(hostResources, assetManager);
    &#125; else if (isVivo(hostResources)) &#123;
        newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager);
    &#125; else if (isNubia(hostResources)) &#123;
        newResources = NubiaResourcesCompat.createResources(hostResources, assetManager);
    &#125; else if (isNotRawResources(hostResources)) &#123;
        newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager);
    &#125; else &#123;
        // is raw android resources
        newResources = new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    &#125;
    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : pluginList) &#123;
        plugin.updateResources(newResources);
    &#125;
    
    return newResources;
&#125;
</code></pre>
<h3 id="九、参考内容"><a href="#九、参考内容" class="headerlink" title="九、参考内容"></a>九、参考内容</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OSMI3bGQ5XyEBtsuzliJkw">聊聊 VirtualAPK 插件化框架的开源</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O1W7OGkhFbJ4-NorBcOivQ">VirtualAPK：滴滴 Android 插件化的实践之路</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/didi/VirtualAPK/wiki">VirtualApk GitHub Wiki官方入门文档</a>   </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CEXTMeQaOlubIwo1Lne8Ww">VirtualAPK 资源加载分析</a>   </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eRQwaJUr9y93ANEIfjktnQ">Android插件化快速入门与实例解析（VirtualApk）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Z-Tt6IjgQWpsqmlcDmlWmQ">深度 | 滴滴插件化方案 VirtualApk 源码解析</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TGFsjZvU_qRZbWeNbqW1kQ">插件化探索，滴滴开源框架VirtualAPK的深入分析</a>  </li>
<li>图书推荐《Android插件化开发指南》</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/" rel="tag"># 插件化</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/09/android-touch-event/" rel="prev" title="一文读懂 Android TouchEvent 事件分发、拦截、处理过程">
      <i class="fa fa-chevron-left"></i> 一文读懂 Android TouchEvent 事件分发、拦截、处理过程
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/14/Kotlin-Native-KMM-app-architecture/" rel="next" title="Kotlin/Native KMM项目架构">
      Kotlin/Native KMM项目架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%85%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">一、从代码入口分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81hookInstrumentationAndHandler"><span class="nav-number">2.</span> <span class="nav-text">二、hookInstrumentationAndHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81hookSystemServices"><span class="nav-number">3.</span> <span class="nav-text">三、hookSystemServices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81hook-DataBindingUtil"><span class="nav-number">4.</span> <span class="nav-text">三、hook DataBindingUtil</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84Activity"><span class="nav-number">5.</span> <span class="nav-text">四、支持插件中的Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84Service"><span class="nav-number">6.</span> <span class="nav-text">五、支持插件中的Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84BroadcastReceiver"><span class="nav-number">7.</span> <span class="nav-text">六、支持插件中的BroadcastReceiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84ContentProvider"><span class="nav-number">8.</span> <span class="nav-text">七、支持插件中的ContentProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%94%AF%E6%8C%81%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84Resources"><span class="nav-number">9.</span> <span class="nav-text">八、支持插件中的Resources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9"><span class="nav-number">10.</span> <span class="nav-text">九、参考内容</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">libill</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">libill</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
