<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"libill.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="libill的博客">
<meta property="og:url" content="https://libill.github.io/index.html">
<meta property="og:site_name" content="libill的博客">
<meta property="og:locale">
<meta property="article:author" content="libill">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://libill.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>libill的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">libill的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2021/10/28/kmm-flutter-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/28/kmm-flutter-plugin/" class="post-title-link" itemprop="url">Kotlin/Native 用KMM写Flutter插件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-10-28 12:48:00 / Modified: 12:48:29" itemprop="dateCreated datePublished" datetime="2021-10-28T12:48:00+08:00">2021-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kotlin-Native-用KMM写Flutter插件"><a href="#Kotlin-Native-用KMM写Flutter插件" class="headerlink" title="Kotlin/Native 用KMM写Flutter插件"></a>Kotlin/Native 用KMM写Flutter插件</h2><h3 id="一、用KMM写Flutter插件"><a href="#一、用KMM写Flutter插件" class="headerlink" title="一、用KMM写Flutter插件"></a>一、用KMM写Flutter插件</h3><p>Google官方有一个写Flutter例子<a target="_blank" rel="noopener" href="https://codelabs.developers.google.com/codelabs/write-flutter-plugin">How to write a Flutter plugin</a>，这里把Google <a target="_blank" rel="noopener" href="https://github.com/flutter/codelabs/tree/master/plugin_codelab">plugin_codelab</a> 例子改成用KMM写Flutter插件。</p>
<h3 id="二、如何运行"><a href="#二、如何运行" class="headerlink" title="二、如何运行"></a>二、如何运行</h3><p>Android: run shared/plugin_codelab/example/android</p>
<p>iOS: </p>
<p>1、build shared.framework </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use ./gradlew releaseIOSFramework</span><br><span class="line">or use new version Android Studio sync</span><br></pre></td></tr></table></figure>

<p>2、run shared/plugin_codelab/example/ios</p>
<p>Tips: before run，shared/build/cocoapods/framework/shared.framework should be generated. The shared.h header file shared/build/cocoapods/framework/shared.framework/Headers/shared.h is generated.</p>
<h3 id="三、设计思路"><a href="#三、设计思路" class="headerlink" title="三、设计思路"></a>三、设计思路</h3><p>Android/iOS插件PluginCodelabPlugin只需要实现KMM Module的接口，不写任何逻辑，把逻辑通过接口放在KMM Module中。</p>
<h4 id="1、定义接口中间层用于转发数据"><a href="#1、定义接口中间层用于转发数据" class="headerlink" title="1、定义接口中间层用于转发数据"></a>1、定义接口中间层用于转发数据</h4><p>如参考Flutter插件的MethodCall、MethodChannel，定义CommonMethodCall数据类、CommonMethodChannel.Result接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data class CommonMethodCall(</span><br><span class="line">    val method: String,</span><br><span class="line">    val arguments: Any?,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">class CommonMethodChannel &#123;</span><br><span class="line">    interface Result &#123;</span><br><span class="line">        fun success(result: Any?)</span><br><span class="line"></span><br><span class="line">        fun error(errorCode: String?, errorMessage: String?, errorDetails: Any?)</span><br><span class="line"></span><br><span class="line">        fun notImplemented()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、在KMM中的commonMain实现CommonCodelabPlugin插件的公共逻辑"><a href="#2、在KMM中的commonMain实现CommonCodelabPlugin插件的公共逻辑" class="headerlink" title="2、在KMM中的commonMain实现CommonCodelabPlugin插件的公共逻辑"></a>2、在KMM中的commonMain实现CommonCodelabPlugin插件的公共逻辑</h4><p>CommonCodelabPlugin需要初始化并启动synth?.start()，处理getPlatformVersion、onKeyDown、onKeyUp逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class CommonCodelabPlugin &#123;</span><br><span class="line"></span><br><span class="line">    private val synth = Synth()</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        synth?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun onMethodCall(call: CommonMethodCall, result: CommonMethodChannel.Result) &#123;</span><br><span class="line">        when (call.method) &#123;</span><br><span class="line">            &quot;getPlatformVersion&quot; -&gt; &#123;</span><br><span class="line">                result.success(Platform().platform)</span><br><span class="line">            &#125;</span><br><span class="line">            &quot;onKeyDown&quot; -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    val arguments = call.arguments as List&lt;*&gt;</span><br><span class="line">                    val numKeysDown = synth?.keyDown((arguments[0] as Int))</span><br><span class="line">                    result.success(numKeysDown)</span><br><span class="line">                &#125; catch (ex: Exception) &#123;</span><br><span class="line">                    result.error(&quot;1&quot;, ex.message, ex.cause)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &quot;onKeyUp&quot; -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    val arguments = call.arguments as List&lt;*&gt;</span><br><span class="line">                    val numKeysDown = synth?.keyUp((arguments[0] as Int))</span><br><span class="line">                    result.success(numKeysDown)</span><br><span class="line">                &#125; catch (ex: Exception) &#123;</span><br><span class="line">                    result.error(&quot;1&quot;, ex.message, ex.cause)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; &#123;</span><br><span class="line">                result.notImplemented()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有包括插件名称也属于公共逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 插件Channel名称</span><br><span class="line">const val PLUGIN_CODE_LAB_CHANNEL = &quot;plugin_codelab&quot;</span><br></pre></td></tr></table></figure>

<h4 id="3、实现平台差异特性"><a href="#3、实现平台差异特性" class="headerlink" title="3、实现平台差异特性"></a>3、实现平台差异特性</h4><p>这里只列出expect接口，具体实现平台差异特性类请查看源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expect class Synth() &#123;</span><br><span class="line">    fun start()</span><br><span class="line"></span><br><span class="line">    fun keyDown(key: Int): Int</span><br><span class="line"></span><br><span class="line">    fun keyUp(key: Int): Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect class Platform() &#123;</span><br><span class="line">    val platform: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、Android-Flutter实现插件KMM接口"><a href="#4、Android-Flutter实现插件KMM接口" class="headerlink" title="4、Android Flutter实现插件KMM接口"></a>4、Android Flutter实现插件KMM接口</h4><p>Android Flutter实现插件KMM接口，注意这里只实现接口用于中转Flutter与Android/iOS 数据，不能有任何业务逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class PluginCodelabPlugin : FlutterPlugin, MethodCallHandler &#123;</span><br><span class="line">    private var channel: MethodChannel? = null</span><br><span class="line">    private var commonCodelabPlugin: CommonCodelabPlugin? = null</span><br><span class="line"></span><br><span class="line">    override fun onAttachedToEngine(flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) &#123;</span><br><span class="line">        setup(this, flutterPluginBinding.binaryMessenger)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) &#123;</span><br><span class="line">        commonCodelabPlugin?.onMethodCall(</span><br><span class="line">            call = CommonMethodCall(call.method, call.arguments),</span><br><span class="line">            result = object : CommonMethodChannel.Result &#123;</span><br><span class="line">                override fun success(successResult: Any?) &#123;</span><br><span class="line">                    result.success(successResult)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun error(errorCode: String?, errorMessage: String?, errorDetails: Any?) &#123;</span><br><span class="line">                    result.error(errorCode, errorMessage, errorDetails)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun notImplemented() &#123;</span><br><span class="line">                    result.notImplemented()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) &#123;</span><br><span class="line">        channel?.setMethodCallHandler(null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private fun setup(plugin: PluginCodelabPlugin, binaryMessenger: BinaryMessenger) &#123;</span><br><span class="line">            plugin.channel = MethodChannel(binaryMessenger, PLUGIN_CODE_LAB_CHANNEL)</span><br><span class="line">            plugin.channel?.setMethodCallHandler(plugin)</span><br><span class="line">            plugin.commonCodelabPlugin = CommonCodelabPlugin()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、iOS-Flutter实现插件KMM接口"><a href="#5、iOS-Flutter实现插件KMM接口" class="headerlink" title="5、iOS Flutter实现插件KMM接口"></a>5、iOS Flutter实现插件KMM接口</h4><p>Android Flutter实现插件KMM接口，注意这里只实现接口用于中转Flutter与Android/iOS 数据，不能有任何业务逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;PluginCodelabPlugin.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation PluginCodelabPlugin&#123;</span><br><span class="line">  int _numKeysDown;</span><br><span class="line">  FlutterResult _flutterResult;</span><br><span class="line">  SharedCommonCodelabPlugin* _codelabPlugin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">  self = [super init];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    // create music</span><br><span class="line">    _codelabPlugin = [[SharedCommonCodelabPlugin alloc] init];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    // destroy music</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123;</span><br><span class="line">  FlutterMethodChannel* channel = [FlutterMethodChannel</span><br><span class="line">      methodChannelWithName: SharedPluginCodeLabKt.PLUGIN_CODE_LAB_CHANNEL</span><br><span class="line">            binaryMessenger:[registrar messenger]];</span><br><span class="line">  PluginCodelabPlugin* instance = [[PluginCodelabPlugin alloc] init];</span><br><span class="line">  [registrar addMethodCallDelegate:instance channel:channel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleMethodCall:(FlutterMethodCall *)call</span><br><span class="line">                  result:(FlutterResult)result &#123;</span><br><span class="line">    SharedCommonMethodCall *methodCall = [[SharedCommonMethodCall alloc] initWithMethod:call.method arguments:call.arguments];</span><br><span class="line">    _flutterResult = result;</span><br><span class="line">    [_codelabPlugin onMethodCallCall:methodCall result:self ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)errorErrorCode:(NSString * _Nullable)errorCode errorMessage:(NSString * _Nullable)errorMessage errorDetails:(id _Nullable)errorDetails &#123;</span><br><span class="line">    NSError *error = [NSError errorWithDomain:NSCocoaErrorDomain code:errorCode.intValue userInfo:@&#123;@&quot;errorMessage&quot;:errorMessage, @&quot;errorDetails&quot;:errorDetails&#125;];</span><br><span class="line">    if (_flutterResult) &#123;</span><br><span class="line">        _flutterResult(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)notImplemented &#123;</span><br><span class="line">    if (_flutterResult) &#123;</span><br><span class="line">        _flutterResult(FlutterMethodNotImplemented);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)successResult:(id _Nullable)result &#123;</span><br><span class="line">    if (_flutterResult) &#123;</span><br><span class="line">        _flutterResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>到这里，已经完成了使用KMM开发一个Flutter插件。使用KMM开发插件的好处是公共逻辑都使用kotlin写，一般公共逻辑比较简单适合使用kotlin写，便于维护。而且，实现了KMM写插件，Flutter写UI。</p>
<h3 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h3><p>Github项目地址：<a target="_blank" rel="noopener" href="https://github.com/libill/kmm-flutter-plugin">kmm-flutter-plugin</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2021/10/14/Kotlin-Native-KMM-app-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/14/Kotlin-Native-KMM-app-architecture/" class="post-title-link" itemprop="url">Kotlin/Native KMM项目架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-10-14 20:08:00 / Modified: 20:26:13" itemprop="dateCreated datePublished" datetime="2021-10-14T20:08:00+08:00">2021-10-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kotlin-Native-KMM项目架构"><a href="#Kotlin-Native-KMM项目架构" class="headerlink" title="Kotlin/Native KMM项目架构"></a>Kotlin/Native KMM项目架构</h2><h3 id="一、什么是KMM？"><a href="#一、什么是KMM？" class="headerlink" title="一、什么是KMM？"></a>一、什么是KMM？</h3><p>Kotlin Multiplatform Mobile ( KMM ) 是一个 SDK，旨在简化跨平台移动应用程序的创建。在 KMM 的帮助下，您可以在 iOS 和 Android 应用程序之间共享通用代码，并仅在必要时编写特定于平台的代码。</p>
<p>KMM用纯Kotlin编写一次代码，即可在iOS和Android上运行，开发应用的公共业务逻辑只需要编写一次。KMM减少了为不同平台编写和维护相同代码所花费的时间。在Jenkins上一次构建可以产出aar、framework、klib，Android依赖aar，iOS依赖framework，性能与原生一致。当然可以使用KMM依赖klib开发Android、iOS应用。</p>
<p><img src="http://libill.github.io/2021/10/14/Kotlin-Native-KMM-app-architecture/KMM%E6%9E%84%E5%BB%BA.png"></p>
<h3 id="二、KMM项目架构"><a href="#二、KMM项目架构" class="headerlink" title="二、KMM项目架构"></a>二、KMM项目架构</h3><p>项目架构主要分为原生系统层、Android/iOS业务SDK层、KMM SDK层、KMM业务逻辑SDK层、iOS sdkframework层、Android/iOS App层。</p>
<p><img src="http://libill.github.io/2021/10/14/Kotlin-Native-KMM-app-architecture/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.png"></p>
<p>原生系统层：这里提下原生系统层的目的是，有些平台特性需要分开实现，比如读取文件、打印日志、摄像头等。</p>
<p>Android/iOS业务SDK层：主要是包括一些现有的Android/iOS SDK，需要直接依赖现有SDK来开发KMM时，在commonMain expect声明接口，在androidMain、iosMain actual分别依赖现有SDK实现。这样就可以使用已有的SDK，后续也可以保持接口不变，直接使用KMM实现SDK，如alog、PlatformMMKV。</p>
<p>KMM SDK层：如alog、PlatformMMKV写成一个SDK可以供其他KMM模块(business)使用。</p>
<p>KMM业务逻辑SDK层：具体业务的逻辑模块，比如登录逻辑、获取首页列表逻辑、查看首页列表数据详情等。</p>
<p>iOS sdkframework层：Kotlin/Native构建一个framework时，产物是二进制，也包含了Kotlin/Native的基础库、Runtime，会使包大小增加1M+左右，而且多个Kotlin/Native构建的framework不会共享基础库导致每一个framework都会增加1M+，为了避免包过大，统一构建一个framework。</p>
<p>App层：Android的依赖无变化，依赖aar或者jar；iOS依赖sdkframework，这样iOS包大小只增加1M+。当然如果依赖了一些库如ktor网络库，包也会变大，避免这个问题也可以不用依赖ktor，直接依赖现有的网络库来实现一个KMM SDK。</p>
<p><img src="http://libill.github.io/2021/10/14/Kotlin-Native-KMM-app-architecture/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p>
<h3 id="三、使用expect-actual编写平台特定的代码"><a href="#三、使用expect-actual编写平台特定的代码" class="headerlink" title="三、使用expect/actual编写平台特定的代码"></a>三、使用expect/actual编写平台特定的代码</h3><p>以打印日志为例，打造一个alog日志SDK</p>
<p>在commonMain定义IALog接口，声明fun v函数，其他函数忽略。并定义expect ALogImpl类来实现平台特性打印日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IALog &#123;</span><br><span class="line">    fun v(tag: String, message: String)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect class ALogImpl(): IALog</span><br></pre></td></tr></table></figure>

<p>在androidMain实现ALogImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import android.util.Log</span><br><span class="line">actual class ALogImpl actual constructor() : IALog &#123;</span><br><span class="line">    override fun v(tag: String, message: String) &#123;</span><br><span class="line">        Log.v(tag, message)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iosMain实现ALogImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import platform.Foundation.NSLog</span><br><span class="line">internal actual class ALogImpl actual constructor(): IALog &#123;</span><br><span class="line">    override fun v(tag: String, message: String) &#123;</span><br><span class="line">        NSLog(&quot;[$tag] $message&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，我们已经使用KMM实现了一个alog日志SDK。</p>
<h3 id="四、依赖现有的Android-iOS-SDK开发KMM-SDK"><a href="#四、依赖现有的Android-iOS-SDK开发KMM-SDK" class="headerlink" title="四、依赖现有的Android/iOS SDK开发KMM SDK"></a>四、依赖现有的Android/iOS SDK开发KMM SDK</h3><p>alog的实现过于简单，使用了android.util.Log、platform.Foundation.NSLog。如果使用现有的Android/iOS SDK，如何实现呢？比如Android使用mars-xlog、iOS使用CocoaLumberjack</p>
<p>Android的实现没什么变化，依赖mars-xlog即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;com.tencent.mars:mars-xlog:1.2.6&quot;)</span><br><span class="line"></span><br><span class="line">import com.tencent.mars.xlog.Log</span><br><span class="line">actual class ALogImpl actual constructor() : IALog &#123;</span><br><span class="line">    override fun v(tag: String, message: String) &#123;</span><br><span class="line">        Log.v(tag, message)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ios实现依赖CocoaLumberjack，需要用到native.cocoapods插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    kotlin(&quot;multiplatform&quot;)</span><br><span class="line">    kotlin(&quot;native.cocoapods&quot;)</span><br><span class="line">    id(&quot;com.android.library&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cocoapods &#123;</span><br><span class="line">    ...</span><br><span class="line">    frameworkName = &quot;alog&quot;</span><br><span class="line">    pod(&quot;CocoaLumberjack&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过cinterop一些gradle Task会自动生成头文件给iosMain使用，比如生成alog-cinterop-CocoaLumberjack.klib包含1_CocoaLumberjack.knm。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cocoapods.CocoaLumberjack.*</span><br><span class="line">internal actual class ALogImpl actual constructor(): IALog &#123;</span><br><span class="line">    private val dLog = DDLog</span><br><span class="line">    override fun v(tag: String, message: String) &#123;</span><br><span class="line">        dLog.log(asynchronousLog, toMessage(tag, &quot;[$tag] $message&quot;, DDLogLevelVerbose, DDLogFlagVerbose))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun toMessage(tag: String, message: String, level: DDLogLevel, flag: DDLogFlag): DDLogMessage &#123;</span><br><span class="line">        return DDLogMessage(message, level, flag, 0, &quot;&quot;, null, 0, tag, 0, null)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便Android/iOS App使用,添加一个ALog.kt类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Android App使用 ALog.i(tag, message)</span><br><span class="line"> */</span><br><span class="line">val ALog: IALog by lazy &#123; ALogImpl() &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * iOS App使用ALogKt.i(tag, message)</span><br><span class="line"> */</span><br><span class="line">fun d(tag: String, message: String) = ALog.d(tag, message)</span><br></pre></td></tr></table></figure>

<p>到此，alog就完成了依赖现有的Android/iOS SDK（mars-xlog、CocoaLumberjack）开发alog KMM SDK。</p>
<h3 id="五、声明Android-iOS公共接口以及独有接口"><a href="#五、声明Android-iOS公共接口以及独有接口" class="headerlink" title="五、声明Android/iOS公共接口以及独有接口"></a>五、声明Android/iOS公共接口以及独有接口</h3><p>用expect修饰commonMain中声明公共的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect interface IALog &#123;</span><br><span class="line">    fun v(tag: String, message: String)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iosMain中用actual修饰来实现真正的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actual interface IALog &#123;</span><br><span class="line">    actual fun v(tag: String, message: String)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在androidMain中用actual修饰来实现真正的接口，带actual修饰的方法为Android/iOS公共方法，不带actual修饰的方法为Android独有(Android有这个接口iOS没有这个接口)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actual interface IALog &#123;</span><br><span class="line">    actual fun v(tag: String, message: String)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    fun v(tag: String, format: String, vararg args: Any?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样Android就可以使用fun v(tag: String, format: String, vararg args: Any?)函数，而iOS没有这个函数。好处是通常一些SDK在commonMain中会定义一套公共接口，有时候Android或iOS有一些独有接口，就可以用这种方式声明。同理data class也是可以这样使用。</p>
<h3 id="六、为iOS统一构建成一个framework"><a href="#六、为iOS统一构建成一个framework" class="headerlink" title="六、为iOS统一构建成一个framework"></a>六、为iOS统一构建成一个framework</h3><p>为了避免Kotlin/Native构建framework时包过大，统一构建一个framework，下面把包名称为sdkframework。这里提一下几个值得注意的问题。有2种方式构建：1、本地构建，写一个sdkframework项目依赖其他模块的klib包，来构建sdkframework。2、构建系统上构建依赖其他模块的klib包构建，业务直接pod sdkframework即可。第1种方案比较灵活，版本号可以写脚本控制，但是要求开发人员使用的电脑都要配置KMM开发环境。第2种方案业务接入更加简单，跟iOS原生开发的SDK一样，无需KMM环境，主要问题是各个业务依赖klib的版本不一致,导致构建sdkframework多个版本，这时需要用不同分支构建不同业务的sdkframework，版本号加后缀来区别 1.0.0-love、1.0.0-like。</p>
<h4 id="6-1-sdkframework模块的iosMain需要有一个kotlin文件"><a href="#6-1-sdkframework模块的iosMain需要有一个kotlin文件" class="headerlink" title="6.1 sdkframework模块的iosMain需要有一个kotlin文件"></a>6.1 sdkframework模块的iosMain需要有一个kotlin文件</h4><p>如果iosMain没有kotlin文件，将无法生成 iOS framework，为其添加一个文件即可，如SDKTest.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 加个类，避免Framework没生成</span><br><span class="line">class SDKTest &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-生成头文件sdkframework-h时，把注释也带上"><a href="#6-2-生成头文件sdkframework-h时，把注释也带上" class="headerlink" title="6.2 生成头文件sdkframework.h时，把注释也带上"></a>6.2 生成头文件sdkframework.h时，把注释也带上</h4><p>生成头文件sdkframework.h时，如果需要把注释也带上，那需要在gradle中添加Task</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets.withType&lt;org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget&gt; &#123;</span><br><span class="line">    compilations.get(&quot;main&quot;).kotlinOptions.freeCompilerArgs += &quot;-Xexport-kdoc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-依赖的模块需要使用export来导出到sdkframework-h头文件中"><a href="#6-3-依赖的模块需要使用export来导出到sdkframework-h头文件中" class="headerlink" title="6.3 依赖的模块需要使用export来导出到sdkframework.h头文件中"></a>6.3 依赖的模块需要使用export来导出到sdkframework.h头文件中</h4><p>sdkframework依赖了utils、alog、PlatformMMKV、business，需要添加export，把这几个模块的类和方法导出到sdkframework.h头文件中，这样iosApp才可以使用这几个模块的类和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val iosX64 = iosX64()</span><br><span class="line">val iosArm64 = iosArm64()</span><br><span class="line">targets &#123;</span><br><span class="line">    configure(listOf(iosX64, iosArm64)) &#123;</span><br><span class="line">        binaries.withType(org.jetbrains.kotlin.gradle.plugin.mpp.Framework::class.java) &#123;</span><br><span class="line">            export(project(&quot;:utils&quot;))</span><br><span class="line">            export(project(&quot;:alog&quot;))</span><br><span class="line">            export(project(&quot;:PlatformMMKV&quot;))</span><br><span class="line">            export(project(&quot;:business&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-sdkframework本地依赖的模块使用了pod-sdkframework也要pod，以klib依赖可避免该问题"><a href="#6-4-sdkframework本地依赖的模块使用了pod-sdkframework也要pod，以klib依赖可避免该问题" class="headerlink" title="6.4 sdkframework本地依赖的模块使用了pod,sdkframework也要pod，以klib依赖可避免该问题"></a>6.4 sdkframework本地依赖的模块使用了pod,sdkframework也要pod，以klib依赖可避免该问题</h4><p>sdkframework依赖utils、alog、PlatformMMKV、business模块源码构建framework时，模块使用了pod的，那sdkframework也要pod。如PlatformMMKV pod(“MMKV”, “1.2.8”),那sdkframework也要pod(“MMKV”, “1.2.8”)。那如何避免这个问题，可以先把utils、alog、PlatformMMKV、business模块在构建系统上构建成klib，sdkframework依赖各个模块的klib即可。</p>
<h4 id="6-5-use-frameworks-和-use-modular-headers"><a href="#6-5-use-frameworks-和-use-modular-headers" class="headerlink" title="6.5 use_frameworks! 和 use_modular_headers!"></a>6.5 use_frameworks! 和 use_modular_headers!</h4><p>上面说到的第1点本地构建，在iosApp本地依赖构建sdkframework时，要将依赖项正确导入 Kotlin/Native 模块，Podfile必须包含use_modular_headers! 或 use_frameworks! 指令，查看文档<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/native-cocoapods.html#use-a-kotlin-gradle-project-as-a-cocoapods-dependency">链接</a>。当然，如果是第2点构建系统上构建则不需要使用这2个指令。</p>
<h3 id="七、参考链接："><a href="#七、参考链接：" class="headerlink" title="七、参考链接："></a>七、参考链接：</h3><p>1、<a target="_blank" rel="noopener" href="https://github.com/libill/kmmApp">源码地址</a>:<a target="_blank" rel="noopener" href="https://github.com/libill/kmmApp">https://github.com/libill/kmmApp</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/kmm-getting-started.html">kmm-getting-started</a></p>
<p>3、<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/multiplatform.html">Multiplatform programming</a></p>
<p>4、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/e3k5JcxG1FvGlNkOyjNIFw">KMM 求生日记二：Kotlin/Native 被踩中的坑</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2019/10/29/learn-virtualapk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/29/learn-virtualapk/" class="post-title-link" itemprop="url">深入理解VirtualApk插件化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-29 14:37:00" itemprop="dateCreated datePublished" datetime="2019-10-29T14:37:00+08:00">2019-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-08 15:45:02" itemprop="dateModified" datetime="2021-10-08T15:45:02+08:00">2021-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是插件化？</p>
<p>插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的包名和版本号，包名可以区别宿主和各个插件，版本号可用于宿主和插件的升级。</p>
<p>简单介绍下VirtualAPK</p>
<p>VirtualAPK对插件没有额外的约束，原生的apk即可作为插件。插件工程编译生成apk后，即可通过宿主App加载，每个插件apk被加载后，都会在宿主中创建一个单独的LoadedPlugin对象。如下图所示，通过这些LoadedPlugin对象，VirtualAPK就可以管理插件并赋予插件新的意义，使其可以像手机中安装过的App一样运行。</p>
<h3 id="一、从代码入口分析"><a href="#一、从代码入口分析" class="headerlink" title="一、从代码入口分析"></a>一、从代码入口分析</h3><p>代码分析基于0.9.8版本</p>
<pre><code>compile &#39;com.didi.virtualapk:core:0.9.8&#39;
</code></pre>
<p>VirtualApk初始化插件引擎需要在Application的attachBaseContext进行</p>
<pre><code>public class VAApplication extends Application &#123;

    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        PluginManager.getInstance(base).init();
    &#125;

&#125;
</code></pre>
<p>getInstalce方法用单例设计模式创建PluginManager对象，使用了synchronized关键字同步锁</p>
<pre><code>public static PluginManager getInstance(Context base) &#123;
    if (sInstance == null) &#123;
        synchronized (PluginManager.class) &#123;
            if (sInstance == null) &#123;
                sInstance = createInstance(base);
            &#125;
        &#125;
    &#125;

    return sInstance;
&#125;
</code></pre>
<p>创建PluginManager对象后，接着会调用hookCurrentProcess方法</p>
<pre><code>protected void hookCurrentProcess() &#123;
    hookInstrumentationAndHandler();
    hookSystemServices();
    hookDataBindingUtil();
&#125;
</code></pre>
<p>到这里可以知道，hook了Instrumentation、Handler、SystemServices、DataBindingUtil。下面逐个分析下这四个hook流程，这里分析流程的目的是要了解hook是怎么回事，hook了是要干嘛呢。</p>
<h3 id="二、hookInstrumentationAndHandler"><a href="#二、hookInstrumentationAndHandler" class="headerlink" title="二、hookInstrumentationAndHandler"></a>二、hookInstrumentationAndHandler</h3><p>先看看hookInstrumentationAndHandler的代码</p>
<pre><code>protected void hookInstrumentationAndHandler() &#123;
    try &#123;
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Instrumentation baseInstrumentation = activityThread.getInstrumentation();

        final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);
        
        Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);
        Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
        Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);
        this.mInstrumentation = instrumentation;
        Log.d(TAG, &quot;hookInstrumentationAndHandler succeed : &quot; + mInstrumentation);
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>第一行ActivityThread activityThread = ActivityThread.currentActivityThread();这里会不会让你想起什么来，ActivityThread是一个@hide类，为什么可以直接使用@hide类呢？可以按点击去试试看，会跳到AndroidStub模块下的ActivityThread。AndroidStub定义了许多路径一样的类但是里面都是实现抛出RuntimeException.为了尽量避免使用反射浪费性能，使用了AndroidStub模块来欺骗编译器。欺骗编译器需要查看Android framework层源码，定义和原码中一摸一样的方法，实现抛出RuntimeException。CoreLibrary使用provided依赖AndroidStub，provided依赖是不打包依赖包，而是运行时提供，所以成功欺骗了编辑器，用来提高了性能。</p>
<pre><code>public final class ActivityThread &#123;

    public static ActivityThread currentActivityThread() &#123;
        throw new RuntimeException(&quot;Stub!&quot;);
    &#125;
    ...
&#125;
</code></pre>
<p>CoreLibrary使用provided依赖AndroidStub</p>
<pre><code>final String projectAndroidStub = &#39;:AndroidStub&#39;
dependencies &#123;
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    provided project(projectAndroidStub)
&#125;
</code></pre>
<p>现在回到hook instrumentation上，使用了Reflector反射器直接把framework层的ActivityThread类下mInstrumentation变量变成了VAInstrumentation，使得VAInstrumentation起到了代理作用。</p>
<pre><code>final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);
Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);
</code></pre>
<p>代理的目的就是先让VAInstrumentation处理自己的逻辑，处理完后再给framework层的Instrumentation处理，以实现达到欺骗系统的作用，校验的是宿主占坑Activity，启动插件中的Activity。</p>
<pre><code>public class VAInstrumentation extends Instrumentation implements Handler.Callback &#123;
...
protected Instrumentation mBase;

@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123;
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
&#125;

protected void injectIntent(Intent intent) &#123;
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) &#123;
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    &#125;
&#125;
...
&#125;
</code></pre>
<p>现在来看看hook Handler,</p>
<pre><code>Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);
</code></pre>
<p>看看ActivityThread源码下getHandler()是什么?原来是H类。</p>
<pre><code>public final class ActivityThread extends ClientTransactionHandler &#123;
    ...
    final H mH = new H();
    final Handler getHandler() &#123;
        return mH;
    &#125;
    ...
&#125;
</code></pre>
<p>那为什么可以直接把H类的mCallback直接替换成功VAInstrumentation实现的Handler.Callback不会引起其他问题，导致无法执行H类的handleMessage呢？看看Handler源码就知道了。new H()的时候mCallback为null，使用代理VAInstrumentation后mCallback.handleMessage(msg)会一直返回false，会继续执行handleMessage方法。起到了代理H类的效果，先执行VAInstrumentation的handleMessage,再执行H类的handleMessage。</p>
<pre><code>public class Handler &#123;
    ...
    public Handler() &#123;
        this(null, false);
    &#125;

    public Handler(Callback callback, boolean async) &#123;
        ...
        mCallback = callback;
        mAsynchronous = async;
    &#125;

    public void dispatchMessage(Message msg) &#123;
        if (msg.callback != null) &#123;
            handleCallback(msg);
        &#125; else &#123;
            if (mCallback != null) &#123;
                if (mCallback.handleMessage(msg)) &#123;
                    return;
                &#125;
            &#125;
            handleMessage(msg);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png"></p>
<h3 id="三、hookSystemServices"><a href="#三、hookSystemServices" class="headerlink" title="三、hookSystemServices"></a>三、hookSystemServices</h3><p>hook SystemServices的时候，先从ActivityManager.class或ActivityManagerNative.class中反射获取Singleton<IActivityManager>对象，再使用ActivityManagerProxy动态代理动态代理获取一个 IActivityManager.</p>
<pre><code>protected void hookSystemServices() &#123;
    try &#123;
        Singleton&lt;IActivityManager&gt; defaultSingleton;

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;
            defaultSingleton = Reflector.on(ActivityManager.class).field(&quot;IActivityManagerSingleton&quot;).get();
        &#125; else &#123;
            defaultSingleton = Reflector.on(ActivityManagerNative.class).field(&quot;gDefault&quot;).get();
        &#125;
        IActivityManager origin = defaultSingleton.get();
        IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] &#123; IActivityManager.class &#125;,
            createActivityManagerProxy(origin));

        // Hook IActivityManager from ActivityManagerNative
        Reflector.with(defaultSingleton).field(&quot;mInstance&quot;).set(activityManagerProxy);

        if (defaultSingleton.get() == activityManagerProxy) &#123;
            this.mActivityManager = activityManagerProxy;
            Log.d(TAG, &quot;hookSystemServices succeed : &quot; + mActivityManager);
        &#125;
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>ActivityManager.class下的IActivityManagerSingleton</p>
<pre><code>public class ActivityManager &#123;
    ...
    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
            new Singleton&lt;IActivityManager&gt;() &#123;
                @Override
                protected IActivityManager create() &#123;
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                &#125;
            &#125;;
    &#125;
    ...
&#125;
</code></pre>
<p>Reflector.with(defaultSingleton).field(“mInstance”).set(activityManagerProxy);这里的mInstance其实是Singleton<T>类的mInstance变量。</p>
<pre><code>public abstract class Singleton&lt;T&gt; &#123;
    private T mInstance;

    protected abstract T create();

    public final T get() &#123;
        synchronized (this) &#123;
            if (mInstance == null) &#123;
                mInstance = create();
            &#125;
            return mInstance;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="三、hook-DataBindingUtil"><a href="#三、hook-DataBindingUtil" class="headerlink" title="三、hook DataBindingUtil"></a>三、hook DataBindingUtil</h3><p>分析完上面2个原理，到这里应该比较清晰hook是什么回事了，就是在执行framework层代码之前，先执行Proxy代理的代码，来实现一些意想不到的效果。hook DataBindingUtil可以自己看看代码分析下。</p>
<pre><code>protected void hookDataBindingUtil() &#123;
    Reflector.QuietReflector reflector = Reflector.QuietReflector.on(&quot;android.databinding.DataBindingUtil&quot;).field(&quot;sMapper&quot;);
    Object old = reflector.get();
    if (old != null) &#123;
        try &#123;
            Callback callback = Reflector.on(&quot;android.databinding.DataBinderMapperProxy&quot;).constructor().newInstance();
            reflector.set(callback);
            addCallback(callback);
            Log.d(TAG, &quot;hookDataBindingUtil succeed : &quot; + callback);
        &#125; catch (Reflector.ReflectedException e) &#123;
            Log.w(TAG, e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="四、支持插件中的Activity"><a href="#四、支持插件中的Activity" class="headerlink" title="四、支持插件中的Activity"></a>四、支持插件中的Activity</h3><p>这里需要了解Activity的启动流程，如果你还没有了解可以点击这里。前面我们了解了hook Instrumentation,看看VAInstrumentation到底做了什么。启动Activity时会执行execStartActivity，而在执行execStartActivity之前做了injectIntent，是为了绕过系统校验是否在宿主的AndroidManifest.xml中注册过插件中的Activity。也就是要达到插件中的Activity不用在宿主中注册就可以启动。</p>
<pre><code>@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123;
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
&#125;

protected void injectIntent(Intent intent) &#123;
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) &#123;
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    &#125;
&#125;
</code></pre>
<p>transformIntentToExplicitAsNeeded作用是把隐式启动的Activity转化为显式启动。下图可以知道把Intent { act=com.didi.virtualapk.plugin.BookManagerActivity }转化为显式Intent { act=com.didi.virtualapk.plugin.BookManagerActivity cmp=com.didi.virtualapk.demo/.aidl.BookManagerActivity }，ComponentName由null变成包含BookManagerActivity数据的ComponentName。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity_Action.png"></p>
<p>markIntentIfNeeded其实就是记录了下插件的信息包括isPlugin、插件package、要启动的插件Activity类，记录的目的是绕过系统校验后，再把这些信息取出来，启动真正要启动的插件Activity。</p>
<pre><code>public void markIntentIfNeeded(Intent intent) &#123;
    if (intent.getComponent() == null) &#123;
        return;
    &#125;

    String targetPackageName = intent.getComponent().getPackageName();
    String targetClassName = intent.getComponent().getClassName();
    // search map and return specific launchmode stub activity
    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123;
        intent.putExtra(Constants.KEY_IS_PLUGIN, true);
        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);
        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);
        dispatchStubActivity(intent);
    &#125;
&#125;
</code></pre>
<p>这里要看看dispatchStubActivity把targetActivity替换成stubActivity的过程。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity.png"></p>
<p>图中可以看到stubActivity是com.didi.virtualapk.core.A$1，这是CoreLibrary/src/main/AndroidManifest.xml下提前注册占坑Activity。包含了四种启动模式，不同的启动模式取不同的占坑Activity，达到支持插件Activity的四种启动模式。</p>
<pre><code>&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$1&quot; android:launchMode=&quot;standard&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$2&quot; android:launchMode=&quot;standard&quot;
    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$1&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$2&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$3&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$4&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$5&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$6&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$7&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$8&quot; android:launchMode=&quot;singleTop&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$1&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$2&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$3&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$4&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$5&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$6&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$7&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$8&quot; android:launchMode=&quot;singleTask&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$1&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$2&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$3&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$4&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$5&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$6&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$7&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$8&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
</code></pre>
<p>如果想了解如何取对应设计模式的占坑，可以查看StubActivityInfo类，如取值stubActivity为com.didi.virtualapk.core.A$1</p>
<pre><code>public static final String STUB_ACTIVITY_STANDARD = &quot;%s.A$%d&quot;;
stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);
</code></pre>
<p>injectIntent绕过校验后，会执行newActivity,在classloader加载占坑类com.didi.virtualapk.core.A$1时，由于只是占坑，不存在这个类，会走ClassNotFoundException异常逻辑。</p>
<pre><code>@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;
    try &#123;
        cl.loadClass(className);
        Log.i(TAG, String.format(&quot;newActivity[%s]&quot;, className));
        
    &#125; catch (ClassNotFoundException e) &#123;
        ComponentName component = PluginUtil.getComponent(intent);
        
        if (component == null) &#123;
            return newActivity(mBase.newActivity(cl, className, intent));
        &#125;

        String targetClassName = component.getClassName();
        Log.i(TAG, String.format(&quot;newActivity[%s : %s/%s]&quot;, className, component.getPackageName(), targetClassName));

        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(component);

        if (plugin == null) &#123;
            // Not found then goto stub activity.
            boolean debuggable = false;
            try &#123;
                Context context = this.mPluginManager.getHostContext();
                debuggable = (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;
            &#125; catch (Throwable ex) &#123;
    
            &#125;

            if (debuggable) &#123;
                throw new ActivityNotFoundException(&quot;error intent: &quot; + intent.toURI());
            &#125;
            
            Log.i(TAG, &quot;Not found. starting the stub activity: &quot; + StubActivity.class);
            return newActivity(mBase.newActivity(cl, StubActivity.class.getName(), intent));
        &#125;
        
        Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
        activity.setIntent(intent);

        // for 4.1+
        Reflector.QuietReflector.with(activity).field(&quot;mResources&quot;).set(plugin.getResources());

        return newActivity(activity);
    &#125;

    return newActivity(mBase.newActivity(cl, className, intent));
&#125;
</code></pre>
<p>通过this.mPluginManager.getLoadedPlugin(component)获取已经加载的插件，并重新设置了恢复了要启动的插件Activity。就这样callActivityOnCreate的时候也是调用要启动的插件Activity。</p>
<pre><code>@Override
public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;
    injectActivity(activity);
    mBase.callActivityOnCreate(activity, icicle);
&#125;
</code></pre>
<h3 id="五、支持插件中的Service"><a href="#五、支持插件中的Service" class="headerlink" title="五、支持插件中的Service"></a>五、支持插件中的Service</h3><p>前面已经了解了hookSystemServices的过程，是使用了动态代理生成代理类。</p>
<pre><code>IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] &#123; IActivityManager.class &#125;,
    createActivityManagerProxy(origin));
</code></pre>
<p>再看看createActivityManagerProxy做了什么</p>
<pre><code>protected ActivityManagerProxy createActivityManagerProxy(IActivityManager origin) throws Exception &#123;
    return new ActivityManagerProxy(this, origin);
&#125;
</code></pre>
<p>既然用了动态代理，那就看看ActivityManagerProxy的invoke方法</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    if (&quot;startService&quot;.equals(method.getName())) &#123;
        try &#123;
            return startService(proxy, method, args);
        &#125; catch (Throwable e) &#123;
            Log.e(TAG, &quot;Start service error&quot;, e);
        &#125;
    &#125; else if (&quot;stopService&quot;.equals(method.getName())) &#123;
        try &#123;
            return stopService(proxy, method, args);
        &#125; catch (Throwable e) &#123;
            Log.e(TAG, &quot;Stop Service error&quot;, e);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p>在执行Service生命周期等关键方法时都做了相应的代理处理，看看startService</p>
<pre><code>protected Object startService(Object proxy, Method method, Object[] args) throws Throwable &#123;
    IApplicationThread appThread = (IApplicationThread) args[0];
    Intent target = (Intent) args[1];
    ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0);
    if (null == resolveInfo || null == resolveInfo.serviceInfo) &#123;
        // is host service
        return method.invoke(this.mActivityManager, args);
    &#125;

    return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);
&#125;
</code></pre>
<p>resolveService判断是不是宿主工程的Service，宿主Service走原来的逻辑，插件Service就走startDelegateServiceForTarget</p>
<pre><code>public ResolveInfo resolveService(Intent intent, int flags) &#123;
    for (LoadedPlugin plugin : this.mPlugins.values()) &#123;
        ResolveInfo resolveInfo = plugin.resolveService(intent, flags);
        if (null != resolveInfo) &#123;
            return resolveInfo;
        &#125;
    &#125;

    return null;
&#125;
</code></pre>
<p>startDelegateServiceForTarget里面执行wrapperTargetIntent，</p>
<pre><code>protected ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123;
    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);
    return mPluginManager.getHostContext().startService(wrapperIntent);
&#125;
</code></pre>
<p>关键点local ? LocalService.class : RemoteService.class，明确了需要哪个Service做代理类。</p>
<pre><code>protected Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123;
    // fill in service with ComponentName
    target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name));
    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();

    // start delegate service to run plugin service inside
    boolean local = PluginUtil.isLocalService(serviceInfo);
    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;
    Intent intent = new Intent();
    intent.setClass(mPluginManager.getHostContext(), delegate);
    intent.putExtra(RemoteService.EXTRA_TARGET, target);
    intent.putExtra(RemoteService.EXTRA_COMMAND, command);
    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);
    if (extras != null) &#123;
        intent.putExtras(extras);
    &#125;

    return intent;
&#125;
</code></pre>
<p>RemoteService继承了LocalService，RemoteService作用是loadPlugin，其他工作交给LocalService。这样做也合理，如果是插件的交给RemoteService来loadPlugin，省下的逻辑都是相同的交给LocalService处理就可以了。</p>
<pre><code>public int onStartCommand(Intent intent, int flags, int startId) &#123;
    if (intent == null) &#123;
        return super.onStartCommand(intent, flags, startId);
    &#125;

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    if (target != null) &#123;
        String pluginLocation = intent.getStringExtra(EXTRA_PLUGIN_LOCATION);
        ComponentName component = target.getComponent();
        LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(component);
        if (plugin == null &amp;&amp; pluginLocation != null) &#123;
            try &#123;
                PluginManager.getInstance(this).loadPlugin(new File(pluginLocation));
            &#125; catch (Exception e) &#123;
                Log.w(TAG, e);
            &#125;
        &#125;
    &#125;

    return super.onStartCommand(intent, flags, startId);
&#125;
</code></pre>
<p>LocalService按照service的启动流程，loadClass先加载service，反射调用attach，在调用onCreate方法，rememberService记录attach后的service,再调用service.onStartCommand执行命令。如果是启动了的直接调用onStartCommand。</p>
<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) &#123;
    if (null == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) &#123;
        return START_STICKY;
    &#125;

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    int command = intent.getIntExtra(EXTRA_COMMAND, 0);
    if (null == target || command &lt;= 0) &#123;
        return START_STICKY;
    &#125;

    ComponentName component = target.getComponent();
    LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component);
    
    if (plugin == null) &#123;
        Log.w(TAG, &quot;Error target: &quot; + target.toURI());
        return START_STICKY;
    &#125;
    // ClassNotFoundException when unmarshalling in Android 5.1
    target.setExtrasClassLoader(plugin.getClassLoader());
    switch (command) &#123;
        case EXTRA_COMMAND_START_SERVICE: &#123;
            ActivityThread mainThread = ActivityThread.currentActivityThread();
            IApplicationThread appThread = mainThread.getApplicationThread();
            Service service;

            if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123;
                service = this.mPluginManager.getComponentsHandler().getService(component);
            &#125; else &#123;
                try &#123;
                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();

                    Application app = plugin.getApplication();
                    IBinder token = appThread.asBinder();
                    Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);
                    IActivityManager am = mPluginManager.getActivityManager();

                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);
                    service.onCreate();
                    this.mPluginManager.getComponentsHandler().rememberService(component, service);
                &#125; catch (Throwable t) &#123;
                    return START_STICKY;
                &#125;
            &#125;

            service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());
            break;
        &#125;
        ...
    &#125;

    return START_STICKY;
&#125;
</code></pre>
<p>TODO：分析动态代理思想</p>
<h3 id="六、支持插件中的BroadcastReceiver"><a href="#六、支持插件中的BroadcastReceiver" class="headerlink" title="六、支持插件中的BroadcastReceiver"></a>六、支持插件中的BroadcastReceiver</h3><p>思路是动态注册广播，将静态注册的广播转变为动态注册，将插件中静态注册的receiver使用mHostContext重新注册一遍。具体代码可以在LoadedPlugin构造方法查看。</p>
<pre><code>public LoadedPlugin(PluginManager pluginManager, Context context, File apk) throws Exception &#123;
    ...

    // Register broadcast receivers dynamically
    Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();
    for (PackageParser.Activity receiver : this.mPackage.receivers) &#123;
        receivers.put(receiver.getComponentName(), receiver.info);

        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());
        for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123;
            this.mHostContext.registerReceiver(br, aii);
        &#125;
    &#125;
    this.mReceiverInfos = Collections.unmodifiableMap(receivers);
    this.mPackageInfo.receivers = receivers.values().toArray(new ActivityInfo[receivers.size()]);

    // try to invoke plugin&#39;s application
    invokeApplication();
&#125;
</code></pre>
<p>再看看查询所有的receivers，先对比ComponentName是否相同，component为空时再用intent等去匹配。</p>
<pre><code>public List&lt;ResolveInfo&gt; queryBroadcastReceivers(Intent intent, int flags) &#123;
    ComponentName component = intent.getComponent();
    List&lt;ResolveInfo&gt; resolveInfos = new ArrayList&lt;ResolveInfo&gt;();
    ContentResolver resolver = this.mPluginContext.getContentResolver();

    for (PackageParser.Activity receiver : this.mPackage.receivers) &#123;
        if (receiver.getComponentName().equals(component)) &#123;
            ResolveInfo resolveInfo = new ResolveInfo();
            resolveInfo.activityInfo = receiver.info;
            resolveInfos.add(resolveInfo);
        &#125; else if (component == null) &#123;
            // only match implicit intent
            for (PackageParser.ActivityIntentInfo intentInfo : receiver.intents) &#123;
                if (intentInfo.match(resolver, intent, true, TAG) &gt;= 0) &#123;
                    ResolveInfo resolveInfo = new ResolveInfo();
                    resolveInfo.activityInfo = receiver.info;
                    resolveInfos.add(resolveInfo);
                    break;
                &#125;
            &#125;
        &#125;
    &#125;

    return resolveInfos;
&#125;
</code></pre>
<h3 id="七、支持插件中的ContentProvider"><a href="#七、支持插件中的ContentProvider" class="headerlink" title="七、支持插件中的ContentProvider"></a>七、支持插件中的ContentProvider</h3><p>先看一下插件化是如何使用ContentProvider的，获取插件LoadedPlugin后，通过PluginContentResolver的wrapperUri转化Uri为后续支持读取的Uri。</p>
<pre><code>// test ContentProvider
Uri bookUri = Uri.parse(&quot;content://com.didi.virtualapk.demo.book.provider/book&quot;);
LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(pkg);
bookUri = PluginContentResolver.wrapperUri(plugin, bookUri);

Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);
if (bookCursor != null) &#123;
    while (bookCursor.moveToNext()) &#123;
        int bookId = bookCursor.getInt(0);
        String bookName = bookCursor.getString(1);
        Log.d(&quot;ryg&quot;, &quot;query book:&quot; + bookId + &quot;, &quot; + bookName);
    &#125;
    bookCursor.close();
&#125;
</code></pre>
<p>是用wrapperUri转化下Uri后就可以正常读取ContentProvider的数据了。这里使用到了RemoteContentProvider，这个转化其实就是后面会使用到RemoteContentProvider。</p>
<pre><code>public static Uri wrapperUri(LoadedPlugin loadedPlugin, Uri pluginUri) &#123;
    String pkg = loadedPlugin.getPackageName();
    String pluginUriString = Uri.encode(pluginUri.toString());
    StringBuilder builder = new StringBuilder(RemoteContentProvider.getUri(loadedPlugin.getHostContext()));
    builder.append(&quot;/?plugin=&quot; + loadedPlugin.getLocation());
    builder.append(&quot;&amp;pkg=&quot; + pkg);
    builder.append(&quot;&amp;uri=&quot; + pluginUriString);
    Uri wrapperUri = Uri.parse(builder.toString());
    return wrapperUri;
&#125;
</code></pre>
<p>wrapperUri会拼接成</p>
<pre><code>content://com.libill.virtualapk.VirtualAPK.Provider/?plugin=/storage/emulated/0/Test.apk&amp;pkg=com.didi.virtualapk.demo&amp;uri=content%3A%2F%2Fcom.didi.virtualapk.demo.book.provider%2Fbook
</code></pre>
<p>我们先看看pluginManager.loadPlugin(apk)时做了一些解释数据，并缓存起来。</p>
<pre><code>// Cache providers
Map&lt;String, ProviderInfo&gt; providers = new HashMap&lt;String, ProviderInfo&gt;();
Map&lt;ComponentName, ProviderInfo&gt; providerInfos = new HashMap&lt;ComponentName, ProviderInfo&gt;();
for (PackageParser.Provider provider : this.mPackage.providers) &#123;
    providers.put(provider.info.authority, provider.info);
    providerInfos.put(provider.getComponentName(), provider.info);
&#125;
this.mProviders = Collections.unmodifiableMap(providers);
this.mProviderInfos = Collections.unmodifiableMap(providerInfos);
this.mPackageInfo.providers = providerInfos.values().toArray(new ProviderInfo[providerInfos.size()]);
</code></pre>
<p>当使用getContentResolver的query时，会通过IPC通信，调用acquireProvider获取IContentProvider的binder对象。而PluginContentResolver对acquireProvider等多个方法做了代理。</p>
<pre><code>@Override
protected IContentProvider acquireProvider(Context context, String auth) &#123;
    if (mPluginManager.resolveContentProvider(auth, 0) != null) &#123;
        return mPluginManager.getIContentProvider();
    &#125;
    return super.acquireProvider(context, auth);
&#125;
</code></pre>
<p>在getIContentProvider方法，做了hook IContentProvider动作。</p>
<pre><code>public synchronized IContentProvider getIContentProvider() &#123;
    if (mIContentProvider == null) &#123;
        hookIContentProviderAsNeeded();
    &#125;

    return mIContentProvider;
&#125;
</code></pre>
<p>使用了反射器对mProviderMap反射操作，获取mProviderMap来能获取到占坑的 Provider。对authority、mProvider做了setAccessible(true)，最终IContentProviderProxy.newInstance生成IContentProviderProxy对象。这里还使用了RemoteContentProvider包装Uri。</p>
<pre><code>protected void hookIContentProviderAsNeeded() &#123;
    Uri uri = Uri.parse(RemoteContentProvider.getUri(mContext));
    mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null);
    try &#123;
        Field authority = null;
        Field provider = null;
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Map providerMap = Reflector.with(activityThread).field(&quot;mProviderMap&quot;).get();
        Iterator iter = providerMap.entrySet().iterator();
        while (iter.hasNext()) &#123;
            Map.Entry entry = (Map.Entry) iter.next();
            Object key = entry.getKey();
            Object val = entry.getValue();
            String auth;
            if (key instanceof String) &#123;
                auth = (String) key;
            &#125; else &#123;
                if (authority == null) &#123;
                    authority = key.getClass().getDeclaredField(&quot;authority&quot;);
                    authority.setAccessible(true);
                &#125;
                auth = (String) authority.get(key);
            &#125;
            if (auth.equals(RemoteContentProvider.getAuthority(mContext))) &#123;
                if (provider == null) &#123;
                    provider = val.getClass().getDeclaredField(&quot;mProvider&quot;);
                    provider.setAccessible(true);
                &#125;
                IContentProvider rawProvider = (IContentProvider) provider.get(val);
                IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider);
                mIContentProvider = proxy;
                Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider);
                break;
            &#125;
        &#125;
    &#125; catch (Exception e) &#123;
        Log.w(TAG, e);
    &#125;
&#125;
</code></pre>
<p>IContentProvider使用了动态代理方式</p>
<pre><code>public static IContentProvider newInstance(Context context, IContentProvider iContentProvider) &#123;
    return (IContentProvider) Proxy.newProxyInstance(iContentProvider.getClass().getClassLoader(),
            new Class[] &#123; IContentProvider.class &#125;, new IContentProviderProxy(context, iContentProvider));
&#125;
</code></pre>
<p>看看invoke方法，使用wrapperUri后直接调用method.invoke</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    Log.v(TAG, method.toGenericString() + &quot; : &quot; + Arrays.toString(args));
    wrapperUri(method, args);

    try &#123;
        return method.invoke(mBase, args);
    &#125; catch (InvocationTargetException e) &#123;
        throw e.getTargetException();
    &#125;
&#125;
</code></pre>
<p>在RemoteContentProvider的getContentProvider可以看到加载和使用插件的ContentProvider。</p>
<pre><code>private ContentProvider getContentProvider(final Uri uri) &#123;
    final PluginManager pluginManager = PluginManager.getInstance(getContext());
    Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI));
    final String auth = pluginUri.getAuthority();
    ContentProvider cachedProvider = sCachedProviders.get(auth);
    if (cachedProvider != null) &#123;
        return cachedProvider;
    &#125;

    synchronized (sCachedProviders) &#123;
        LoadedPlugin plugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
        if (plugin == null) &#123;
            try &#123;
                pluginManager.loadPlugin(new File(uri.getQueryParameter(KEY_PLUGIN)));
            &#125; catch (Exception e) &#123;
                Log.w(TAG, e);
            &#125;
        &#125;

        final ProviderInfo providerInfo = pluginManager.resolveContentProvider(auth, 0);
        if (providerInfo != null) &#123;
            RunUtil.runOnUiThread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    try &#123;
                        LoadedPlugin loadedPlugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
                        ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance();
                        contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);
                        sCachedProviders.put(auth, contentProvider);
                    &#125; catch (Exception e) &#123;
                        Log.w(TAG, e);
                    &#125;
                &#125;
            &#125;, true);
            return sCachedProviders.get(auth);
        &#125;
    &#125;

    return null;
&#125;
</code></pre>
<h3 id="八、支持插件中的Resources"><a href="#八、支持插件中的Resources" class="headerlink" title="八、支持插件中的Resources"></a>八、支持插件中的Resources</h3><p>资源的加载入口时加载插件时生成LoadedPlugin对象，这时开始加载资源。</p>
<pre><code>this.mResources = createResources(context, getPackageName(), apk);
</code></pre>
<p>Constants.COMBINE_RESOURCES一直为true，直接进入ResourcesManager.createResources</p>
<pre><code>protected Resources createResources(Context context, String packageName, File apk) throws Exception &#123;
    if (Constants.COMBINE_RESOURCES) &#123;
        return ResourcesManager.createResources(context, packageName, apk);
    &#125; else &#123;
        Resources hostResources = context.getResources();
        AssetManager assetManager = createAssetManager(context, apk);
        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    &#125;
&#125;
</code></pre>
<p>createResources加载资源后，用hook Resources一遍</p>
<pre><code>public static synchronized Resources createResources(Context hostContext, String packageName, File apk) throws Exception &#123;
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;
        return createResourcesForN(hostContext, packageName, apk);
    &#125;
    
    Resources resources = ResourcesManager.createResourcesSimple(hostContext, apk.getAbsolutePath());
    ResourcesManager.hookResources(hostContext, resources);
    return resources;
&#125;
</code></pre>
<p>createResourcesForN是兼容N</p>
<pre><code>@TargetApi(Build.VERSION_CODES.N)
private static Resources createResourcesForN(Context context, String packageName, File apk) throws Exception &#123;
    long startTime = System.currentTimeMillis();
    String newAssetPath = apk.getAbsolutePath();
    ApplicationInfo info = context.getApplicationInfo();
    String baseResDir = info.publicSourceDir;
    
    info.splitSourceDirs = append(info.splitSourceDirs, newAssetPath);
    LoadedApk loadedApk = Reflector.with(context).field(&quot;mPackageInfo&quot;).get();

    Reflector rLoadedApk = Reflector.with(loadedApk).field(&quot;mSplitResDirs&quot;);
    String[] splitResDirs = rLoadedApk.get();
    rLoadedApk.set(append(splitResDirs, newAssetPath));

    final android.app.ResourcesManager resourcesManager = android.app.ResourcesManager.getInstance();
    ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; originalMap = Reflector.with(resourcesManager).field(&quot;mResourceImpls&quot;).get();

    synchronized (resourcesManager) &#123;
        HashMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; resolvedMap = new HashMap&lt;&gt;();

        if (Build.VERSION.SDK_INT &gt;= 28
            || (Build.VERSION.SDK_INT == 27 &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != 0)) &#123; // P Preview
            ResourcesManagerCompatForP.resolveResourcesImplMap(originalMap, resolvedMap, context, loadedApk);

        &#125; else &#123;
            ResourcesManagerCompatForN.resolveResourcesImplMap(originalMap, resolvedMap, baseResDir, newAssetPath);
        &#125;

        originalMap.clear();
        originalMap.putAll(resolvedMap);
    &#125;

    android.app.ResourcesManager.getInstance().appendLibAssetForMainAssetPath(baseResDir, packageName + &quot;.vastub&quot;);

    Resources newResources = context.getResources();

    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : PluginManager.getInstance(context).getAllLoadedPlugins()) &#123;
        plugin.updateResources(newResources);
    &#125;

    Log.d(TAG, &quot;createResourcesForN cost time: +&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);
    return newResources;
&#125;
</code></pre>
<p>按照系统版本、厂家来兼容</p>
<pre><code>private static Resources createResourcesSimple(Context hostContext, String apk) throws Exception &#123;
    Resources hostResources = hostContext.getResources();
    Resources newResources = null;
    AssetManager assetManager;
    Reflector reflector = Reflector.on(AssetManager.class).method(&quot;addAssetPath&quot;, String.class);
    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;
        assetManager = AssetManager.class.newInstance();
        reflector.bind(assetManager);
        final int cookie1 = reflector.call(hostContext.getApplicationInfo().sourceDir);;
        if (cookie1 == 0) &#123;
            throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + hostContext.getApplicationInfo().sourceDir);
        &#125;
    &#125; else &#123;
        assetManager = hostResources.getAssets();
        reflector.bind(assetManager);
    &#125;
    final int cookie2 = reflector.call(apk);
    if (cookie2 == 0) &#123;
        throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + apk);
    &#125;
    List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins();
    for (LoadedPlugin plugin : pluginList) &#123;
        final int cookie3 = reflector.call(plugin.getLocation());
        if (cookie3 == 0) &#123;
            throw new RuntimeException(&quot;createResources failed, can&#39;t addAssetPath for &quot; + plugin.getLocation());
        &#125;
    &#125;
    if (isMiUi(hostResources)) &#123;
        newResources = MiUiResourcesCompat.createResources(hostResources, assetManager);
    &#125; else if (isVivo(hostResources)) &#123;
        newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager);
    &#125; else if (isNubia(hostResources)) &#123;
        newResources = NubiaResourcesCompat.createResources(hostResources, assetManager);
    &#125; else if (isNotRawResources(hostResources)) &#123;
        newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager);
    &#125; else &#123;
        // is raw android resources
        newResources = new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    &#125;
    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : pluginList) &#123;
        plugin.updateResources(newResources);
    &#125;
    
    return newResources;
&#125;
</code></pre>
<h3 id="九、参考内容"><a href="#九、参考内容" class="headerlink" title="九、参考内容"></a>九、参考内容</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OSMI3bGQ5XyEBtsuzliJkw">聊聊 VirtualAPK 插件化框架的开源</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/O1W7OGkhFbJ4-NorBcOivQ">VirtualAPK：滴滴 Android 插件化的实践之路</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/didi/VirtualAPK/wiki">VirtualApk GitHub Wiki官方入门文档</a>   </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CEXTMeQaOlubIwo1Lne8Ww">VirtualAPK 资源加载分析</a>   </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eRQwaJUr9y93ANEIfjktnQ">Android插件化快速入门与实例解析（VirtualApk）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Z-Tt6IjgQWpsqmlcDmlWmQ">深度 | 滴滴插件化方案 VirtualApk 源码解析</a>  </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TGFsjZvU_qRZbWeNbqW1kQ">插件化探索，滴滴开源框架VirtualAPK的深入分析</a>  </li>
<li>图书推荐《Android插件化开发指南》</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2019/09/09/android-touch-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/09/android-touch-event/" class="post-title-link" itemprop="url">一文读懂 Android TouchEvent 事件分发、拦截、处理过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-09 09:21:04" itemprop="dateCreated datePublished" datetime="2019-09-09T09:21:04+08:00">2019-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-08 15:45:02" itemprop="dateModified" datetime="2021-10-08T15:45:02+08:00">2021-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是事件？事件是用户触摸手机屏幕，引起的一系列TouchEvent，包括ACTION_DOWN、ACTION_MOVE、ACTION_UP、ACTION_CANCEL等，这些action组合后变成点击事件、长按事件等。</p>
<p>在这篇文章中，用打Log测试的方法来了解Android TouchEvent 事件分发，拦截，处理过程。虽然看了一些其他的文章和源码及相关的资料，但是还是觉得需要打下Log和画图来了解一下，不然很容易忘记了事件传递的整个过程。所以写下这篇文章，达到看完这篇文章基本可以了解整个过程，并且可以自己画图画出来给别人看。</p>
<p>先看几个类，主要是画出一个3个ViewGroup叠加的界面，并在事件分发、拦截、处理时打下Log.</p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_demo.png"></p>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/libill/TouchEventDemo">https://github.com/libill/TouchEventDemo</a></p>
<h2 id="一、通过打log分析事件分发"><a href="#一、通过打log分析事件分发" class="headerlink" title="一、通过打log分析事件分发"></a>一、通过打log分析事件分发</h2><p>这里在一个Activity上添加三个ViewGroup来分析，这里值得注意的是Activity、View是没有onInterceptTouchEvent方法的。</p>
<h3 id="一、了解Activity、ViewGroup1、ViewGroup2、ViewGroup3四个类"><a href="#一、了解Activity、ViewGroup1、ViewGroup2、ViewGroup3四个类" class="headerlink" title="一、了解Activity、ViewGroup1、ViewGroup2、ViewGroup3四个类"></a>一、了解Activity、ViewGroup1、ViewGroup2、ViewGroup3四个类</h3><ol>
<li><p>activity_main.xml</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
     &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
 xmlns:tools=&quot;http://schemas.android.com/tools&quot;
 android:layout_width=&quot;match_parent&quot;
 android:layout_height=&quot;match_parent&quot;
 tools:context=&quot;com.touchevent.demo.MyActivity&quot;&gt;
     &lt;com.touchevent.demo.ViewGroup1
     android:layout_width=&quot;match_parent&quot;
     android:layout_height=&quot;match_parent&quot;
     android:background=&quot;@color/colorAccent&quot;&gt;
     &lt;com.touchevent.demo.ViewGroup2
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:layout_margin=&quot;50dp&quot;
         android:background=&quot;@color/colorPrimary&quot;&gt;
         &lt;com.touchevent.demo.ViewGroup3
             android:layout_width=&quot;match_parent&quot;
             android:layout_height=&quot;match_parent&quot;
             android:layout_margin=&quot;50dp&quot;
             android:background=&quot;@color/colorPrimaryDark&quot;&gt;
         &lt;/com.touchevent.demo.ViewGroup3&gt;
     &lt;/com.touchevent.demo.ViewGroup2&gt;
     &lt;/com.touchevent.demo.ViewGroup1&gt;
 &lt;/android.support.constraint.ConstraintLayout&gt;  
</code></pre>
</li>
</ol>
<ol>
<li>主界面：MainActivity.java</li>
</ol>
<pre><code>    public class MyActivity extends AppCompatActivity &#123;
        private final static String TAG = MyActivity.class.getName();
    
        @Override
        protected void onCreate(Bundle savedInstanceState) &#123;
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
        &#125;
    
        @Override
        public boolean dispatchTouchEvent(MotionEvent ev) &#123;
            Log.i(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev));
            boolean superReturn = super.dispatchTouchEvent(ev);
            Log.d(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
            return superReturn;
        &#125;
    
        @Override
        public boolean onTouchEvent(MotionEvent ev) &#123;
            Log.i(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev));
            boolean superReturn = super.onTouchEvent(ev);
            Log.d(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
            return superReturn;
        &#125;
    &#125;
</code></pre>
<ol>
<li>三个ViewGroup，里面的代码完全一样:ViewGroup1.java，ViewGroup2.java，ViewGroup3.java。由于代码一样所以只贴其中一个类。</li>
</ol>
<pre><code>    public class ViewGroup1 extends LinearLayout &#123;
        private final static String TAG = ViewGroup1.class.getName();
    
        public ViewGroup1(Context context) &#123;
            super(context);
        &#125;
    
        public ViewGroup1(Context context, AttributeSet attrs) &#123;
            super(context, attrs);
        &#125;
    
        @Override
        public boolean dispatchTouchEvent(MotionEvent ev) &#123;
            Log.i(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev));
            boolean superReturn = super.dispatchTouchEvent(ev);
            Log.d(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
            return superReturn;
        &#125;
    
        @Override
        public boolean onInterceptTouchEvent(MotionEvent ev) &#123;
            Log.i(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev));
            boolean superReturn = super.onInterceptTouchEvent(ev);
            Log.d(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
            return superReturn;
        &#125;
    
        @Override
        public boolean onTouchEvent(MotionEvent ev) &#123;
            Log.i(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev));
            boolean superReturn = super.onTouchEvent(ev);
            Log.d(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
            return superReturn;
        &#125;
    &#125;
</code></pre>
<h3 id="二、不拦截处理任何事件"><a href="#二、不拦截处理任何事件" class="headerlink" title="二、不拦截处理任何事件"></a>二、不拦截处理任何事件</h3><p>添加没有拦截处理任何事件的代码，看看事件是怎么传递的，选择Info，查看Log.</p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_dispatch_false.png"></p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_dispatch_false_flowchart.jpg"></p>
<p>从流程图可以看出，事件分发从Activity开始，然后分发到ViewGroup，在这个过程中，只要ViewGroup没有拦截处理，最后还是会回到Activity的onTouchEvent方法。</p>
<h3 id="三、ViewGroup2的dispatchTouchEvent返回true"><a href="#三、ViewGroup2的dispatchTouchEvent返回true" class="headerlink" title="三、ViewGroup2的dispatchTouchEvent返回true"></a>三、ViewGroup2的dispatchTouchEvent返回true</h3><p>把ViewGroup2.java的dispatchTouchEvent修改一下，return 返回true使事件不在分发</p>
<pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) &#123;
 Log.i(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev));
 Log.d(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + true);
 return true;
&#125;
</code></pre>
<p>此时的Log</p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_dispatch_true.png"></p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_dispatch_true_flowchart.jpg"></p>
<p> 从图片可以看出，当ViewGroupon2的dispatchTouchEvent返回true后，事件不会再分发传送到ViewGroup3了，也不会分发到Activity的onTouchEvent了。而是事件到了ViewGroupon2的dispatchTouchEvent后，就停止了。dispatchTouchEvent返回true表示着事件不用再分发下去了。</p>
<h3 id="四、ViewGroup2的onInterceptTouchEvent返回true"><a href="#四、ViewGroup2的onInterceptTouchEvent返回true" class="headerlink" title="四、ViewGroup2的onInterceptTouchEvent返回true"></a>四、ViewGroup2的onInterceptTouchEvent返回true</h3><p>把ViewGroup2.java的onInterceptTouchEvent修改一下，return 返回true把事件拦截了</p>
<pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) &#123;
    Log.i(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev));
    boolean superReturn = super.dispatchTouchEvent(ev);
    Log.d(TAG, &quot;dispatchTouchEvent    action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + superReturn);
    return superReturn;
&#125;

@Override
public boolean onInterceptTouchEvent(MotionEvent ev) &#123;
    Log.i(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev));
    Log.d(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + true);
    return true;
&#125;
</code></pre>
<p>此时的Log</p>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_viewgroup2_intercept_true.png"><br><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_intercept_true.jpg"></p>
<p>可以看出ViewGroup2拦截了事件，就不会继续分发到ViewGroup3；而且ViewGroup3拦截了事件又不处理事件，会把事件传递到Activity的onTouchEvent方法。</p>
<h3 id="五、ViewGroup2的onInterceptTouchEvent、onTouchEvent返回true"><a href="#五、ViewGroup2的onInterceptTouchEvent、onTouchEvent返回true" class="headerlink" title="五、ViewGroup2的onInterceptTouchEvent、onTouchEvent返回true"></a>五、ViewGroup2的onInterceptTouchEvent、onTouchEvent返回true</h3><p>把ViewGroup2.java的onTouchEvent修改一下，return 返回true把事件处理了</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) &#123;
    Log.i(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev));
    Log.d(TAG, &quot;onInterceptTouchEvent action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + true);
    return true;
&#125;

@Override
public boolean onTouchEvent(MotionEvent ev) &#123;
    Log.i(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev));
    Log.d(TAG, &quot;onTouchEvent          action:&quot; + StringUtils.getMotionEventName(ev) + &quot; &quot; + true);
    return true;
&#125;
</code></pre>
<p><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_viewgroup2_touch_true.png"><br><img src="http://libill.github.io/2019/09/09/android-touch-event/touch_event_intercept_touch_true.jpg"></p>
<p>从流程可以总结出，当ViewGroup2的onInterceptTouchEvent、onTouchEvent都返回true时，事件最终会走到ViewGroup2的onTouchEvent方法处理事件，后续的事件都会走到这里来。</p>
<p>上面通过log分析很清楚了，是不是就这样够了？其实还不行，还要从源码的角度去分析下，为什么事件会这样分发。</p>
<h2 id="二、通过源码分析事件分发"><a href="#二、通过源码分析事件分发" class="headerlink" title="二、通过源码分析事件分发"></a>二、通过源码分析事件分发</h2><h3 id="一、Activity的dispatchTouchEvent"><a href="#一、Activity的dispatchTouchEvent" class="headerlink" title="一、Activity的dispatchTouchEvent"></a>一、Activity的dispatchTouchEvent</h3><p>先看看Activity下的dispatchTouchEvent</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) &#123;
    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
        onUserInteraction();
    &#125;
    if (getWindow().superDispatchTouchEvent(ev)) &#123;
        return true;
    &#125;
    return onTouchEvent(ev);
&#125;
</code></pre>
<p>onUserInteraction方法</p>
<pre><code>public void onUserInteraction() &#123;
&#125;
</code></pre>
<p>从代码可以了解</p>
<ol>
<li><p>调用Activity的onUserInteraction方法,action为down时会进去onUserInteraction方法，但是这个是空方法不做任何事情，可以忽略。</p>
</li>
<li><p>调用window的superDispatchTouchEvent方法，返回true时事件分发处理结束，否则会调用Activity的onTouchEvent方法。</p>
</li>
<li><p>调用Activity的onTouchEvent方法，进入这个条件的方法是window的superDispatchTouchEvent方法返回false。从上面的分析（二、不拦截处理任何事件）可以知道，所有子View的dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent都返回false时会调动Activity的onTouchEvent方法，这个时候也是使window的superDispatchTouchEvent方法返回false成立。</p>
</li>
</ol>
<h3 id="二、window的superDispatchTouchEvent"><a href="#二、window的superDispatchTouchEvent" class="headerlink" title="二、window的superDispatchTouchEvent"></a>二、window的superDispatchTouchEvent</h3><p>Activity的getWindow方法</p>
<pre><code>public Window getWindow() &#123;
    return mWindow;
&#125;
</code></pre>
<p>mWindow是如何赋值的？<br>是在Activity的attach方法赋值的，其实mWindow是PhoneWindow。</p>
<p>Activity的attach方法</p>
<pre><code>final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback) &#123;
    attachBaseContext(context);

    mFragments.attachHost(null /*parent*/);

    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    mWindow.setWindowControllerCallback(this);
    mWindow.setCallback(this);
    mWindow.setOnWindowDismissedCallback(this);
    mWindow.getLayoutInflater().setPrivateFactory(this);
    ...
&#125;
</code></pre>
<p>PhoneWindow的superDispatchTouchEvent方法</p>
<pre><code>private DecorView mDecor;

@Override
public boolean superDispatchTouchEvent(MotionEvent event) &#123;
    return mDecor.superDispatchTouchEvent(event);
&#125;
</code></pre>
<p>DevorView的superDispatchTouchEvent</p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) &#123;
    return super.dispatchTouchEvent(event);
&#125;
</code></pre>
<p>而mDecor是一个继承FrameLayout的DecorView，就这样把事件分发到ViewGroup上了。</p>
<h3 id="三、ViewGroup的dispatchTouchEvent"><a href="#三、ViewGroup的dispatchTouchEvent" class="headerlink" title="三、ViewGroup的dispatchTouchEvent"></a>三、ViewGroup的dispatchTouchEvent</h3><h4 id="3-1-ViewGroup拦截事件的情况"><a href="#3-1-ViewGroup拦截事件的情况" class="headerlink" title="3.1 ViewGroup拦截事件的情况"></a>3.1 ViewGroup拦截事件的情况</h4><pre><code>        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) &#123;
            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) &#123;
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
            &#125; else &#123;
                intercepted = false;
            &#125;
        &#125; else &#123;
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        &#125;
</code></pre>
<p>这里分为2种情况会判断是否需要拦截，也就是当某一条件成立时，会执行onInterceptTouchEvent判断是否需要拦截事件。</p>
<ol>
<li><p>当actionMasked == MotionEvent.ACTION_DOWN时。</p>
</li>
<li><p>当mFirstTouchTarget != null时。mFirstTouchTarget是成功处理事件的ViewGroup的子View，也就是ViewGroup的子View在以下情况返回true时，这个在log分析流程图轻易得到：</p>
<p> 2.1 dispatchTouchEvent返回true</p>
<p> 2.2 如果子View是ViewGroup时，onInterceptTouchEvent、onTouchEvent返回true</p>
</li>
</ol>
<p>另外还有一种情况是disallowIntercept为true时，intercepted直接赋值false不进行拦截。FLAG_DISALLOW_INTERCEPT是通过requestDisallowInterceptTouchEvent方法来设置的，用于在子View中设置，设置后ViewGroup只能拦截down事件，无法拦截其他move、up、cancel事件。为什么ViewGroup还能拦截down事件呢？因为ViewGroup在down事件时进行了重置，看看以下代码</p>
<pre><code>// Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) &#123;
    // Throw away all previous state when starting a new touch gesture.
    // The framework may have dropped the up or cancel event for the previous gesture
    // due to an app switch, ANR, or some other state change.
    cancelAndClearTouchTargets(ev);
    resetTouchState();
&#125;

private void resetTouchState() &#123;
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
    mNestedScrollAxes = SCROLL_AXIS_NONE;
&#125;
</code></pre>
<p>通过源码可以了解到，ViewGroup拦截事件后，不再调用onInterceptTouchEvent，而是直接交给mFirstTouchTarget的onTouchEvent处理,如果该onTouchEvent不处理最终会交给Activity的onTouchEvent。</p>
<h4 id="3-2-ViewGroup不拦截事件的情况"><a href="#3-2-ViewGroup不拦截事件的情况" class="headerlink" title="3.2 ViewGroup不拦截事件的情况"></a>3.2 ViewGroup不拦截事件的情况</h4><p>ViewGroup不拦截事件时，会遍历子View，使事件分发到子View进行处理。</p>
<pre><code>final View[] children = mChildren;
for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;
    final int childIndex = getAndVerifyPreorderedIndex(
            childrenCount, i, customOrder);
    final View child = getAndVerifyPreorderedView(
            preorderedList, children, childIndex);

    // If there is a view that has accessibility focus we want it
    // to get the event first and if not handled we will perform a
    // normal dispatch. We may do a double iteration but this is
    // safer given the timeframe.
    if (childWithAccessibilityFocus != null) &#123;
        if (childWithAccessibilityFocus != child) &#123;
            continue;
        &#125;
        childWithAccessibilityFocus = null;
        i = childrenCount - 1;
    &#125;

    if (!canViewReceivePointerEvents(child)
            || !isTransformedTouchPointInView(x, y, child, null)) &#123;
        ev.setTargetAccessibilityFocus(false);
        continue;
    &#125;

    newTouchTarget = getTouchTarget(child);
    if (newTouchTarget != null) &#123;
        // Child is already receiving touch within its bounds.
        // Give it the new pointer in addition to the ones it is handling.
        newTouchTarget.pointerIdBits |= idBitsToAssign;
        break;
    &#125;

    resetCancelNextUpFlag(child);
    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;
        // Child wants to receive touch within its bounds.
        mLastTouchDownTime = ev.getDownTime();
        if (preorderedList != null) &#123;
            // childIndex points into presorted list, find original index
            for (int j = 0; j &lt; childrenCount; j++) &#123;
                if (children[childIndex] == mChildren[j]) &#123;
                    mLastTouchDownIndex = j;
                    break;
                &#125;
            &#125;
        &#125; else &#123;
            mLastTouchDownIndex = childIndex;
        &#125;
        mLastTouchDownX = ev.getX();
        mLastTouchDownY = ev.getY();
        newTouchTarget = addTouchTarget(child, idBitsToAssign);
        alreadyDispatchedToNewTouchTarget = true;
        break;
    &#125;
&#125;
</code></pre>
<h5 id="3-2-1-寻找可接收事件的子View"><a href="#3-2-1-寻找可接收事件的子View" class="headerlink" title="3.2.1 寻找可接收事件的子View"></a>3.2.1 寻找可接收事件的子View</h5><p>通过canViewReceivePointerEvents判断子View是否能够接收到点击事件。必须符合2种情况，缺一不可：1、点击事件的坐标落在在子View的区域内；2、子View没有正在播放动画。满足条件后，调用dispatchTransformedTouchEvent，其实也是调用子View的dispatchTouchEvent。</p>
<pre><code>private static boolean canViewReceivePointerEvents(@NonNull View child) &#123;
    return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
            || child.getAnimation() != null;
&#125;

protected boolean isTransformedTouchPointInView(float x, float y, View child,
        PointF outLocalPoint) &#123;
    final float[] point = getTempPoint();
    point[0] = x;
    point[1] = y;
    transformPointToViewLocal(point, child);
    final boolean isInView = child.pointInView(point[0], point[1]);
    if (isInView &amp;&amp; outLocalPoint != null) &#123;
        outLocalPoint.set(point[0], point[1]);
    &#125;
    return isInView;
&#125;

private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) &#123;
    final boolean handled;
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) &#123;
            handled = super.dispatchTouchEvent(event);
        &#125; else &#123;
            handled = child.dispatchTouchEvent(event);
        &#125;
        event.setAction(oldAction);
        return handled;
    &#125;

    ...

    // Perform any necessary transformations and dispatch.
    if (child == null) &#123;
        handled = super.dispatchTouchEvent(transformedEvent);
    &#125; else &#123;
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (! child.hasIdentityMatrix()) &#123;
            transformedEvent.transform(child.getInverseMatrix());
        &#125;

        handled = child.dispatchTouchEvent(transformedEvent);
    &#125;

    // Done.
    transformedEvent.recycle();
    return handled;
&#125;
</code></pre>
<p>当dispatchTransformedTouchEvent返回true时，结束for循环遍历，赋值newTouchTarget，相当于发现了可以接收事件的View，不用再继续找了。</p>
<pre><code>newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = true;
break;
</code></pre>
<p>在addTouchTarget方法赋值mFirstTouchTarget。</p>
<pre><code>private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;
    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
    target.next = mFirstTouchTarget;
    mFirstTouchTarget = target;
    return target;
&#125;
</code></pre>
<h5 id="3-2-2-ViewGroup自己处理事件"><a href="#3-2-2-ViewGroup自己处理事件" class="headerlink" title="3.2.2 ViewGroup自己处理事件"></a>3.2.2 ViewGroup自己处理事件</h5><p>另一种情况是mFirstTouchTarget为空时，ViewGroup自己处理事件，这里注意第三个参数为null，ViewGroup的super.dispatchTouchEvent将调用View的dispatchTouchEvent。</p>
<pre><code>if (mFirstTouchTarget == null) &#123;
    // No touch targets so treat this as an ordinary view.
    handled = dispatchTransformedTouchEvent(ev, canceled, null,
            TouchTarget.ALL_POINTER_IDS);
&#125;
</code></pre>
<h4 id="3-3-View处理点击事件的过程"><a href="#3-3-View处理点击事件的过程" class="headerlink" title="3.3 View处理点击事件的过程"></a>3.3 View处理点击事件的过程</h4><p>View的dispatchTouchEvent是怎么处理事件的呢？</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) &#123;
    boolean result = false;
    ...
    if (onFilterTouchEventForSecurity(event)) &#123;
        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;
            result = true;
        &#125;
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;
            result = true;
        &#125;

        if (!result &amp;&amp; onTouchEvent(event)) &#123;
            result = true;
        &#125;
    &#125;
    ...
    return result;
&#125;
</code></pre>
<ol>
<li><p>首先使用onFilterTouchEventForSecurity方法过滤不符合应用安全策略的触摸事件。</p>
<pre><code> public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;
     //noinspection RedundantIfStatement
     if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
             &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;
         // Window is obscured, drop this touch.
         return false;
     &#125;
     return true;
 &#125;
</code></pre>
</li>
<li><p>mOnTouchListener != null判断是否设置了OnTouchEvent，设置了就执行mOnTouchListener.onTouch并返回true,不再执行onTouchEvent。这里得出OnTouchEvent的优先级高于OnTouchEvent，便于使用setOnTouchListener设置处理点击事件。</p>
</li>
<li><p>另一种情况是进入onTouchEvent进行处理。</p>
<pre><code> public boolean onTouchEvent(MotionEvent event) &#123;
     final float x = event.getX();
     final float y = event.getY();
     final int viewFlags = mViewFlags;
     final int action = event.getAction();
 
     final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE
             || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
             || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
 
     if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;
         if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;
             setPressed(false);
         &#125;
         mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
         // A disabled view that is clickable still consumes the touch
         // events, it just doesn&#39;t respond to them.
         return clickable;
     &#125;
     ...
 &#125;
</code></pre>
</li>
</ol>
<p>当View不可用时，依然会处理事件，只是看起来不可用。</p>
<p>接着执行mTouchDelegate.onTouchEvent</p>
<pre><code>if (mTouchDelegate != null) &#123;
    if (mTouchDelegate.onTouchEvent(event)) &#123;
        return true;
    &#125;
&#125;
</code></pre>
<p>下面看看up事件是怎么处理的</p>
<pre><code>/**
 * &lt;p&gt;Indicates this view can display a tooltip on hover or long press.&lt;/p&gt;
 * &#123;@hide&#125;
 */
static final int TOOLTIP = 0x40000000;

if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;
    switch (action) &#123;
        case MotionEvent.ACTION_UP:
            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
            if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;
                handleTooltipUp();
            &#125;
            if (!clickable) &#123;
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;
            &#125;
            boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
            if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;
                // take focus if we don&#39;t have it already and we should in
                // touch mode.
                boolean focusTaken = false;
                if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;
                    focusTaken = requestFocus();
                &#125;

                if (prepressed) &#123;
                    // The button is being released before we actually
                    // showed it as pressed.  Make it show the pressed
                    // state now (before scheduling the click) to ensure
                    // the user sees it.
                    setPressed(true, x, y);
                &#125;

                if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;
                    // This is a tap, so remove the longpress check
                    removeLongPressCallback();

                    // Only perform take click actions if we were in the pressed state
                    if (!focusTaken) &#123;
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) &#123;
                            mPerformClick = new PerformClick();
                        &#125;
                        if (!post(mPerformClick)) &#123;
                            performClickInternal();
                        &#125;
                    &#125;
                &#125;

                if (mUnsetPressedState == null) &#123;
                    mUnsetPressedState = new UnsetPressedState();
                &#125;

                if (prepressed) &#123;
                    postDelayed(mUnsetPressedState,
                            ViewConfiguration.getPressedStateDuration());
                &#125; else if (!post(mUnsetPressedState)) &#123;
                    // If the post failed, unpress right now
                    mUnsetPressedState.run();
                &#125;

                removeTapCallback();
            &#125;
            mIgnoreNextUpEvent = false;
            break;
            ...
    &#125;

    return true;
&#125;
</code></pre>
<p>从上面代码可以了解，clickable、TOOLTIP（长按）有一个为true时，就会消耗事件，使onTouchEvent返回true。其中PerformClick内部调用了performClick方法。</p>
<pre><code>public boolean performClick() &#123;
    // We still need to call this method to handle the cases where performClick() was called
    // externally, instead of through performClickInternal()
    notifyAutofillManagerOnClick();

    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnClickListener != null) &#123;
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    &#125; else &#123;
        result = false;
    &#125;

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);

    notifyEnterOrExitForAutoFillIfNeeded(true);

    return result;
&#125;
</code></pre>
<p>如果View设置了OnClickListener，那performClick会调用内部的onClick方法。</p>
<pre><code>public void setOnClickListener(@Nullable OnClickListener l) &#123;
    if (!isClickable()) &#123;
        setClickable(true);
    &#125;
    getListenerInfo().mOnClickListener = l;
&#125;

public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123;
    if (!isLongClickable()) &#123;
        setLongClickable(true);
    &#125;
    getListenerInfo().mOnLongClickListener = l;
&#125;
</code></pre>
<p>通过setOnClickListener设置clickable，通过setOnLongClickListener设置LONG_CLICKABLE长按事件。设置后使得onTouchEvent返回true。到这里我们已经分析完成点击事件的分发过程了。</p>
<p>本文参考以下内容：</p>
<p>1、《Android开发艺术探索》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://libill.github.io/2019/08/06/debug-android-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/06/debug-android-framework/" class="post-title-link" itemprop="url">如何debug android framework 源代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-06 16:27:14" itemprop="dateCreated datePublished" datetime="2019-08-06T16:27:14+08:00">2019-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-08 15:45:02" itemprop="dateModified" datetime="2021-10-08T15:45:02+08:00">2021-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说明：调试Android Framework的Java部分代码，以调试源码android-28为例，需要一个API 28的模拟器配合使用。</p>
<h3 id="一、下载源码"><a href="#一、下载源码" class="headerlink" title="一、下载源码"></a>一、下载源码</h3><p>下载源码方式很多，由于调试Framework只需要java代码即可，这里使用Android Studio的SDK Manager下载，以下载android-28为例</p>
<p><img src="http://libill.github.io/2019/08/06/debug-android-framework/download_android_28.jpg"></p>
<p>下载完后，在sdk/sources下看到android-28源码</p>
<p><img src="http://libill.github.io/2019/08/06/debug-android-framework/source_android_28.jpg"></p>
<h3 id="二、新建一个项目"><a href="#二、新建一个项目" class="headerlink" title="二、新建一个项目"></a>二、新建一个项目</h3><p>包名cn.test.demo，避免com开头是因为源码有com，等下拷贝源码是避免重复</p>
<p><img src="http://libill.github.io/2019/08/06/debug-android-framework/create_new_project.jpg"></p>
<h3 id="三、拷贝源码到项目的java目录下"><a href="#三、拷贝源码到项目的java目录下" class="headerlink" title="三、拷贝源码到项目的java目录下"></a>三、拷贝源码到项目的java目录下</h3><p><img src="http://libill.github.io/2019/08/06/debug-android-framework/copy_sources.jpg"></p>
<p>可以看到项目目录结构</p>
<p><img src="http://libill.github.io/2019/08/06/debug-android-framework/project.jpg"></p>
<h3 id="四、新建一个与源码对应的模拟器"><a href="#四、新建一个与源码对应的模拟器" class="headerlink" title="四、新建一个与源码对应的模拟器"></a>四、新建一个与源码对应的模拟器</h3><p><img src="http://libill.github.io/2019/08/06/debug-android-framework/avd_28.jpg"></p>
<h3 id="五、启动模拟器，选择debug的进程"><a href="#五、启动模拟器，选择debug的进程" class="headerlink" title="五、启动模拟器，选择debug的进程"></a>五、启动模拟器，选择debug的进程</h3><p><img src="http://libill.github.io/2019/08/06/debug-android-framework/select_process.jpg"></p>
<h3 id="六、选择某一个源码类进行调试"><a href="#六、选择某一个源码类进行调试" class="headerlink" title="六、选择某一个源码类进行调试"></a>六、选择某一个源码类进行调试</h3><p>如选择ActivityManagerService的子类UiHandler，handleMessage方法后，在模拟器随便点击启动应用，如短信，即可调试</p>
<p><img src="http://libill.github.io/2019/08/06/debug-android-framework/debug_source.jpg"></p>
<p>更多请参考<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/85425">极客时间-Android开发高手课</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">libill</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">libill</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
