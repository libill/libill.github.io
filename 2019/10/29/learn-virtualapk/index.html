<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="SZP9Q6cuq1" />

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="什么是插件化？ 插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的">
<meta name="keywords" content="插件化">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解VirtualApk插件化">
<meta property="og:url" content="http://yoursite.com/2019/10/29/learn-virtualapk/index.html">
<meta property="og:site_name" content="libill的博客">
<meta property="og:description" content="什么是插件化？ 插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity_Action.png">
<meta property="og:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity.png">
<meta property="og:updated_time" content="2019-10-29T06:53:24.807Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解VirtualApk插件化">
<meta name="twitter:description" content="什么是插件化？ 插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的">
<meta name="twitter:image" content="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png">
  <link rel="canonical" href="http://yoursite.com/2019/10/29/learn-virtualapk/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>深入理解VirtualApk插件化 | libill的博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">libill的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/libill" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/29/learn-virtualapk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="libill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="libill的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">深入理解VirtualApk插件化

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-29 14:37:00 / Modified: 14:53:24" itemprop="dateCreated datePublished" datetime="2019-10-29T14:37:00+08:00">2019-10-29</time>
            </span>
          
            

            
          

          
            <span class="post-meta-item" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>什么是插件化？</p>
<p>插件化包括宿主和插件2部分。把需要实现的模块或功能独立的提取出来，比如相册，每个模块相当于一个独立的apk，这个apk就是一个插件。有一个加载相册插件apk的App叫做宿主，宿主是一个普通的App，但包含了加载插件apk的功能，使得插件apk正常运行。插件化可以减少宿主App的规模，可以把插件apk放到服务器上，当需要使用到相应的功能时再去加载相应的插件apk。宿主和插件都有各自的包名和版本号，包名可以区别宿主和各个插件，版本号可用于宿主和插件的升级。</p>
<p>简单介绍下VirtualAPK</p>
<p>VirtualAPK对插件没有额外的约束，原生的apk即可作为插件。插件工程编译生成apk后，即可通过宿主App加载，每个插件apk被加载后，都会在宿主中创建一个单独的LoadedPlugin对象。如下图所示，通过这些LoadedPlugin对象，VirtualAPK就可以管理插件并赋予插件新的意义，使其可以像手机中安装过的App一样运行。</p>
<h3 id="一、从代码入口分析"><a href="#一、从代码入口分析" class="headerlink" title="一、从代码入口分析"></a>一、从代码入口分析</h3><p>代码分析基于0.9.8版本</p>
<pre><code>compile &apos;com.didi.virtualapk:core:0.9.8&apos;</code></pre><p>VirtualApk初始化插件引擎需要在Application的attachBaseContext进行</p>
<pre><code>public class VAApplication extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        PluginManager.getInstance(base).init();
    }

}</code></pre><p>getInstalce方法用单例设计模式创建PluginManager对象，使用了synchronized关键字同步锁</p>
<pre><code>public static PluginManager getInstance(Context base) {
    if (sInstance == null) {
        synchronized (PluginManager.class) {
            if (sInstance == null) {
                sInstance = createInstance(base);
            }
        }
    }

    return sInstance;
}</code></pre><p>创建PluginManager对象后，接着会调用hookCurrentProcess方法</p>
<pre><code>protected void hookCurrentProcess() {
    hookInstrumentationAndHandler();
    hookSystemServices();
    hookDataBindingUtil();
}</code></pre><p>到这里可以知道，hook了Instrumentation、Handler、SystemServices、DataBindingUtil。下面逐个分析下这四个hook流程，这里分析流程的目的是要了解hook是怎么回事，hook了是要干嘛呢。</p>
<h3 id="二、hookInstrumentationAndHandler"><a href="#二、hookInstrumentationAndHandler" class="headerlink" title="二、hookInstrumentationAndHandler"></a>二、hookInstrumentationAndHandler</h3><p>先看看hookInstrumentationAndHandler的代码</p>
<pre><code>protected void hookInstrumentationAndHandler() {
    try {
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Instrumentation baseInstrumentation = activityThread.getInstrumentation();

        final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);

        Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);
        Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
        Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);
        this.mInstrumentation = instrumentation;
        Log.d(TAG, &quot;hookInstrumentationAndHandler succeed : &quot; + mInstrumentation);
    } catch (Exception e) {
        Log.w(TAG, e);
    }
}</code></pre><p>第一行ActivityThread activityThread = ActivityThread.currentActivityThread();这里会不会让你想起什么来，ActivityThread是一个@hide类，为什么可以直接使用@hide类呢？可以按点击去试试看，会跳到AndroidStub模块下的ActivityThread。AndroidStub定义了许多路径一样的类但是里面都是实现抛出RuntimeException.为了尽量避免使用反射浪费性能，使用了AndroidStub模块来欺骗编译器。欺骗编译器需要查看Android framework层源码，定义和原码中一摸一样的方法，实现抛出RuntimeException。CoreLibrary使用provided依赖AndroidStub，provided依赖是不打包依赖包，而是运行时提供，所以成功欺骗了编辑器，用来提高了性能。</p>
<pre><code>public final class ActivityThread {

    public static ActivityThread currentActivityThread() {
        throw new RuntimeException(&quot;Stub!&quot;);
    }
    ...
}</code></pre><p>CoreLibrary使用provided依赖AndroidStub</p>
<pre><code>final String projectAndroidStub = &apos;:AndroidStub&apos;
dependencies {
    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    provided project(projectAndroidStub)
}</code></pre><p>现在回到hook instrumentation上，使用了Reflector反射器直接把framework层的ActivityThread类下mInstrumentation变量变成了VAInstrumentation，使得VAInstrumentation起到了代理作用。</p>
<pre><code>final VAInstrumentation instrumentation = createInstrumentation(baseInstrumentation);
Reflector.with(activityThread).field(&quot;mInstrumentation&quot;).set(instrumentation);</code></pre><p>代理的目的就是先让VAInstrumentation处理自己的逻辑，处理完后再给framework层的Instrumentation处理，以实现达到欺骗系统的作用，校验的是宿主占坑Activity，启动插件中的Activity。</p>
<pre><code>public class VAInstrumentation extends Instrumentation implements Handler.Callback {
...
protected Instrumentation mBase;

@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) {
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
}

protected void injectIntent(Intent intent) {
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) {
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    }
}
...
}</code></pre><p>现在来看看hook Handler,</p>
<pre><code>Handler mainHandler = Reflector.with(activityThread).method(&quot;getHandler&quot;).call();
Reflector.with(mainHandler).field(&quot;mCallback&quot;).set(instrumentation);</code></pre><p>看看ActivityThread源码下getHandler()是什么?原来是H类。</p>
<pre><code>public final class ActivityThread extends ClientTransactionHandler {
    ...
    final H mH = new H();
    final Handler getHandler() {
        return mH;
    }
    ...
}</code></pre><p>那为什么可以直接把H类的mCallback直接替换成功VAInstrumentation实现的Handler.Callback不会引起其他问题，导致无法执行H类的handleMessage呢？看看Handler源码就知道了。new H()的时候mCallback为null，使用代理VAInstrumentation后mCallback.handleMessage(msg)会一直返回false，会继续执行handleMessage方法。起到了代理H类的效果，先执行VAInstrumentation的handleMessage,再执行H类的handleMessage。</p>
<pre><code>public class Handler {
    ...
    public Handler() {
        this(null, false);
    }

    public Handler(Callback callback, boolean async) {
        ...
        mCallback = callback;
        mAsynchronous = async;
    }

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
    ...
}</code></pre><p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/handleMessage.png" alt></p>
<h3 id="三、hookSystemServices"><a href="#三、hookSystemServices" class="headerlink" title="三、hookSystemServices"></a>三、hookSystemServices</h3><p>hook SystemServices的时候，先从ActivityManager.class或ActivityManagerNative.class中反射获取Singleton<iactivitymanager>对象，再使用ActivityManagerProxy动态代理动态代理获取一个 IActivityManager.</iactivitymanager></p>
<pre><code>protected void hookSystemServices() {
    try {
        Singleton&lt;IActivityManager&gt; defaultSingleton;

        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
            defaultSingleton = Reflector.on(ActivityManager.class).field(&quot;IActivityManagerSingleton&quot;).get();
        } else {
            defaultSingleton = Reflector.on(ActivityManagerNative.class).field(&quot;gDefault&quot;).get();
        }
        IActivityManager origin = defaultSingleton.get();
        IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] { IActivityManager.class },
            createActivityManagerProxy(origin));

        // Hook IActivityManager from ActivityManagerNative
        Reflector.with(defaultSingleton).field(&quot;mInstance&quot;).set(activityManagerProxy);

        if (defaultSingleton.get() == activityManagerProxy) {
            this.mActivityManager = activityManagerProxy;
            Log.d(TAG, &quot;hookSystemServices succeed : &quot; + mActivityManager);
        }
    } catch (Exception e) {
        Log.w(TAG, e);
    }
}</code></pre><p>ActivityManager.class下的IActivityManagerSingleton</p>
<pre><code>public class ActivityManager {
    ...
    private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
            new Singleton&lt;IActivityManager&gt;() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };
    }
    ...
}</code></pre><p>Reflector.with(defaultSingleton).field(“mInstance”).set(activityManagerProxy);这里的mInstance其实是Singleton<t>类的mInstance变量。</t></p>
<pre><code>public abstract class Singleton&lt;T&gt; {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}</code></pre><h3 id="三、hook-DataBindingUtil"><a href="#三、hook-DataBindingUtil" class="headerlink" title="三、hook DataBindingUtil"></a>三、hook DataBindingUtil</h3><p>分析完上面2个原理，到这里应该比较清晰hook是什么回事了，就是在执行framework层代码之前，先执行Proxy代理的代码，来实现一些意想不到的效果。hook DataBindingUtil可以自己看看代码分析下。</p>
<pre><code>protected void hookDataBindingUtil() {
    Reflector.QuietReflector reflector = Reflector.QuietReflector.on(&quot;android.databinding.DataBindingUtil&quot;).field(&quot;sMapper&quot;);
    Object old = reflector.get();
    if (old != null) {
        try {
            Callback callback = Reflector.on(&quot;android.databinding.DataBinderMapperProxy&quot;).constructor().newInstance();
            reflector.set(callback);
            addCallback(callback);
            Log.d(TAG, &quot;hookDataBindingUtil succeed : &quot; + callback);
        } catch (Reflector.ReflectedException e) {
            Log.w(TAG, e);
        }
    }
}</code></pre><h3 id="四、支持插件中的Activity"><a href="#四、支持插件中的Activity" class="headerlink" title="四、支持插件中的Activity"></a>四、支持插件中的Activity</h3><p>这里需要了解Activity的启动流程，如果你还没有了解可以点击这里。前面我们了解了hook Instrumentation,看看VAInstrumentation到底做了什么。启动Activity时会执行execStartActivity，而在执行execStartActivity之前做了injectIntent，是为了绕过系统校验是否在宿主的AndroidManifest.xml中注册过插件中的Activity。也就是要达到插件中的Activity不用在宿主中注册就可以启动。</p>
<pre><code>@Override
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) {
    injectIntent(intent);
    return mBase.execStartActivity(who, contextThread, token, target, intent, requestCode, options);
}

protected void injectIntent(Intent intent) {
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) {
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(), intent.getComponent().getClassName()));
        // resolve intent with Stub Activity if needed
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    }
}</code></pre><p>transformIntentToExplicitAsNeeded作用是把隐式启动的Activity转化为显式启动。下图可以知道把Intent { act=com.didi.virtualapk.plugin.BookManagerActivity }转化为显式Intent { act=com.didi.virtualapk.plugin.BookManagerActivity cmp=com.didi.virtualapk.demo/.aidl.BookManagerActivity }，ComponentName由null变成包含BookManagerActivity数据的ComponentName。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity_Action.png" alt></p>
<p>markIntentIfNeeded其实就是记录了下插件的信息包括isPlugin、插件package、要启动的插件Activity类，记录的目的是绕过系统校验后，再把这些信息取出来，启动真正要启动的插件Activity。</p>
<pre><code>public void markIntentIfNeeded(Intent intent) {
    if (intent.getComponent() == null) {
        return;
    }

    String targetPackageName = intent.getComponent().getPackageName();
    String targetClassName = intent.getComponent().getClassName();
    // search map and return specific launchmode stub activity
    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) {
        intent.putExtra(Constants.KEY_IS_PLUGIN, true);
        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);
        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);
        dispatchStubActivity(intent);
    }
}</code></pre><p>这里要看看dispatchStubActivity把targetActivity替换成stubActivity的过程。</p>
<p><img src="http://libill.github.io/2019/10/29/learn-virtualapk/stubActivity.png" alt></p>
<p>图中可以看到stubActivity是com.didi.virtualapk.core.A$1，这是CoreLibrary/src/main/AndroidManifest.xml下提前注册占坑Activity。包含了四种启动模式，不同的启动模式取不同的占坑Activity，达到支持插件Activity的四种启动模式。</p>
<pre><code>&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$1&quot; android:launchMode=&quot;standard&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.A$2&quot; android:launchMode=&quot;standard&quot;
    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$1&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$2&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$3&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$4&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$5&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$6&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$7&quot; android:launchMode=&quot;singleTop&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.B$8&quot; android:launchMode=&quot;singleTop&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$1&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$2&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$3&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$4&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$5&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$6&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$7&quot; android:launchMode=&quot;singleTask&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.C$8&quot; android:launchMode=&quot;singleTask&quot;/&gt;

&lt;!-- Stub Activities --&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$1&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$2&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$3&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$4&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$5&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$6&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$7&quot; android:launchMode=&quot;singleInstance&quot;/&gt;
&lt;activity android:exported=&quot;false&quot; android:name=&quot;.D$8&quot; android:launchMode=&quot;singleInstance&quot;/&gt;</code></pre><p>如果想了解如何取对应设计模式的占坑，可以查看StubActivityInfo类，如取值stubActivity为com.didi.virtualapk.core.A$1</p>
<pre><code>public static final String STUB_ACTIVITY_STANDARD = &quot;%s.A$%d&quot;;
stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);</code></pre><p>injectIntent绕过校验后，会执行newActivity,在classloader加载占坑类com.didi.virtualapk.core.A$1时，由于只是占坑，不存在这个类，会走ClassNotFoundException异常逻辑。</p>
<pre><code>@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    try {
        cl.loadClass(className);
        Log.i(TAG, String.format(&quot;newActivity[%s]&quot;, className));

    } catch (ClassNotFoundException e) {
        ComponentName component = PluginUtil.getComponent(intent);

        if (component == null) {
            return newActivity(mBase.newActivity(cl, className, intent));
        }

        String targetClassName = component.getClassName();
        Log.i(TAG, String.format(&quot;newActivity[%s : %s/%s]&quot;, className, component.getPackageName(), targetClassName));

        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(component);

        if (plugin == null) {
            // Not found then goto stub activity.
            boolean debuggable = false;
            try {
                Context context = this.mPluginManager.getHostContext();
                debuggable = (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;
            } catch (Throwable ex) {

            }

            if (debuggable) {
                throw new ActivityNotFoundException(&quot;error intent: &quot; + intent.toURI());
            }

            Log.i(TAG, &quot;Not found. starting the stub activity: &quot; + StubActivity.class);
            return newActivity(mBase.newActivity(cl, StubActivity.class.getName(), intent));
        }

        Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
        activity.setIntent(intent);

        // for 4.1+
        Reflector.QuietReflector.with(activity).field(&quot;mResources&quot;).set(plugin.getResources());

        return newActivity(activity);
    }

    return newActivity(mBase.newActivity(cl, className, intent));
}</code></pre><p>通过this.mPluginManager.getLoadedPlugin(component)获取已经加载的插件，并重新设置了恢复了要启动的插件Activity。就这样callActivityOnCreate的时候也是调用要启动的插件Activity。</p>
<pre><code>@Override
public void callActivityOnCreate(Activity activity, Bundle icicle) {
    injectActivity(activity);
    mBase.callActivityOnCreate(activity, icicle);
}</code></pre><h3 id="五、支持插件中的Service"><a href="#五、支持插件中的Service" class="headerlink" title="五、支持插件中的Service"></a>五、支持插件中的Service</h3><p>前面已经了解了hookSystemServices的过程，是使用了动态代理生成代理类。</p>
<pre><code>IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), new Class[] { IActivityManager.class },
    createActivityManagerProxy(origin));</code></pre><p>再看看createActivityManagerProxy做了什么</p>
<pre><code>protected ActivityManagerProxy createActivityManagerProxy(IActivityManager origin) throws Exception {
    return new ActivityManagerProxy(this, origin);
}</code></pre><p>既然用了动态代理，那就看看ActivityManagerProxy的invoke方法</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (&quot;startService&quot;.equals(method.getName())) {
        try {
            return startService(proxy, method, args);
        } catch (Throwable e) {
            Log.e(TAG, &quot;Start service error&quot;, e);
        }
    } else if (&quot;stopService&quot;.equals(method.getName())) {
        try {
            return stopService(proxy, method, args);
        } catch (Throwable e) {
            Log.e(TAG, &quot;Stop Service error&quot;, e);
        }
    }
    ...
}</code></pre><p>在执行Service生命周期等关键方法时都做了相应的代理处理，看看startService</p>
<pre><code>protected Object startService(Object proxy, Method method, Object[] args) throws Throwable {
    IApplicationThread appThread = (IApplicationThread) args[0];
    Intent target = (Intent) args[1];
    ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0);
    if (null == resolveInfo || null == resolveInfo.serviceInfo) {
        // is host service
        return method.invoke(this.mActivityManager, args);
    }

    return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);
}</code></pre><p>resolveService判断是不是宿主工程的Service，宿主Service走原来的逻辑，插件Service就走startDelegateServiceForTarget</p>
<pre><code>public ResolveInfo resolveService(Intent intent, int flags) {
    for (LoadedPlugin plugin : this.mPlugins.values()) {
        ResolveInfo resolveInfo = plugin.resolveService(intent, flags);
        if (null != resolveInfo) {
            return resolveInfo;
        }
    }

    return null;
}</code></pre><p>startDelegateServiceForTarget里面执行wrapperTargetIntent，</p>
<pre><code>protected ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) {
    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);
    return mPluginManager.getHostContext().startService(wrapperIntent);
}</code></pre><p>关键点local ? LocalService.class : RemoteService.class，明确了需要哪个Service做代理类。</p>
<pre><code>protected Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) {
    // fill in service with ComponentName
    target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name));
    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();

    // start delegate service to run plugin service inside
    boolean local = PluginUtil.isLocalService(serviceInfo);
    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;
    Intent intent = new Intent();
    intent.setClass(mPluginManager.getHostContext(), delegate);
    intent.putExtra(RemoteService.EXTRA_TARGET, target);
    intent.putExtra(RemoteService.EXTRA_COMMAND, command);
    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);
    if (extras != null) {
        intent.putExtras(extras);
    }

    return intent;
}</code></pre><p>RemoteService继承了LocalService，RemoteService作用是loadPlugin，其他工作交给LocalService。这样做也合理，如果是插件的交给RemoteService来loadPlugin，省下的逻辑都是相同的交给LocalService处理就可以了。</p>
<pre><code>public int onStartCommand(Intent intent, int flags, int startId) {
    if (intent == null) {
        return super.onStartCommand(intent, flags, startId);
    }

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    if (target != null) {
        String pluginLocation = intent.getStringExtra(EXTRA_PLUGIN_LOCATION);
        ComponentName component = target.getComponent();
        LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(component);
        if (plugin == null &amp;&amp; pluginLocation != null) {
            try {
                PluginManager.getInstance(this).loadPlugin(new File(pluginLocation));
            } catch (Exception e) {
                Log.w(TAG, e);
            }
        }
    }

    return super.onStartCommand(intent, flags, startId);
}</code></pre><p>LocalService按照service的启动流程，loadClass先加载service，反射调用attach，在调用onCreate方法，rememberService记录attach后的service,再调用service.onStartCommand执行命令。如果是启动了的直接调用onStartCommand。</p>
<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (null == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) {
        return START_STICKY;
    }

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    int command = intent.getIntExtra(EXTRA_COMMAND, 0);
    if (null == target || command &lt;= 0) {
        return START_STICKY;
    }

    ComponentName component = target.getComponent();
    LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component);

    if (plugin == null) {
        Log.w(TAG, &quot;Error target: &quot; + target.toURI());
        return START_STICKY;
    }
    // ClassNotFoundException when unmarshalling in Android 5.1
    target.setExtrasClassLoader(plugin.getClassLoader());
    switch (command) {
        case EXTRA_COMMAND_START_SERVICE: {
            ActivityThread mainThread = ActivityThread.currentActivityThread();
            IApplicationThread appThread = mainThread.getApplicationThread();
            Service service;

            if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) {
                service = this.mPluginManager.getComponentsHandler().getService(component);
            } else {
                try {
                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();

                    Application app = plugin.getApplication();
                    IBinder token = appThread.asBinder();
                    Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);
                    IActivityManager am = mPluginManager.getActivityManager();

                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);
                    service.onCreate();
                    this.mPluginManager.getComponentsHandler().rememberService(component, service);
                } catch (Throwable t) {
                    return START_STICKY;
                }
            }

            service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());
            break;
        }
        ...
    }

    return START_STICKY;
}</code></pre><p>TODO：分析动态代理思想</p>
<h3 id="六、支持插件中的BroadcastReceiver"><a href="#六、支持插件中的BroadcastReceiver" class="headerlink" title="六、支持插件中的BroadcastReceiver"></a>六、支持插件中的BroadcastReceiver</h3><p>思路是动态注册广播，将静态注册的广播转变为动态注册，将插件中静态注册的receiver使用mHostContext重新注册一遍。具体代码可以在LoadedPlugin构造方法查看。</p>
<pre><code>public LoadedPlugin(PluginManager pluginManager, Context context, File apk) throws Exception {
    ...

    // Register broadcast receivers dynamically
    Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();
    for (PackageParser.Activity receiver : this.mPackage.receivers) {
        receivers.put(receiver.getComponentName(), receiver.info);

        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());
        for (PackageParser.ActivityIntentInfo aii : receiver.intents) {
            this.mHostContext.registerReceiver(br, aii);
        }
    }
    this.mReceiverInfos = Collections.unmodifiableMap(receivers);
    this.mPackageInfo.receivers = receivers.values().toArray(new ActivityInfo[receivers.size()]);

    // try to invoke plugin&apos;s application
    invokeApplication();
}</code></pre><p>再看看查询所有的receivers，先对比ComponentName是否相同，component为空时再用intent等去匹配。</p>
<pre><code>public List&lt;ResolveInfo&gt; queryBroadcastReceivers(Intent intent, int flags) {
    ComponentName component = intent.getComponent();
    List&lt;ResolveInfo&gt; resolveInfos = new ArrayList&lt;ResolveInfo&gt;();
    ContentResolver resolver = this.mPluginContext.getContentResolver();

    for (PackageParser.Activity receiver : this.mPackage.receivers) {
        if (receiver.getComponentName().equals(component)) {
            ResolveInfo resolveInfo = new ResolveInfo();
            resolveInfo.activityInfo = receiver.info;
            resolveInfos.add(resolveInfo);
        } else if (component == null) {
            // only match implicit intent
            for (PackageParser.ActivityIntentInfo intentInfo : receiver.intents) {
                if (intentInfo.match(resolver, intent, true, TAG) &gt;= 0) {
                    ResolveInfo resolveInfo = new ResolveInfo();
                    resolveInfo.activityInfo = receiver.info;
                    resolveInfos.add(resolveInfo);
                    break;
                }
            }
        }
    }

    return resolveInfos;
}</code></pre><h3 id="七、支持插件中的ContentProvider"><a href="#七、支持插件中的ContentProvider" class="headerlink" title="七、支持插件中的ContentProvider"></a>七、支持插件中的ContentProvider</h3><p>先看一下插件化是如何使用ContentProvider的，获取插件LoadedPlugin后，通过PluginContentResolver的wrapperUri转化Uri为后续支持读取的Uri。</p>
<pre><code>// test ContentProvider
Uri bookUri = Uri.parse(&quot;content://com.didi.virtualapk.demo.book.provider/book&quot;);
LoadedPlugin plugin = PluginManager.getInstance(this).getLoadedPlugin(pkg);
bookUri = PluginContentResolver.wrapperUri(plugin, bookUri);

Cursor bookCursor = getContentResolver().query(bookUri, new String[]{&quot;_id&quot;, &quot;name&quot;}, null, null, null);
if (bookCursor != null) {
    while (bookCursor.moveToNext()) {
        int bookId = bookCursor.getInt(0);
        String bookName = bookCursor.getString(1);
        Log.d(&quot;ryg&quot;, &quot;query book:&quot; + bookId + &quot;, &quot; + bookName);
    }
    bookCursor.close();
}</code></pre><p>是用wrapperUri转化下Uri后就可以正常读取ContentProvider的数据了。这里使用到了RemoteContentProvider，这个转化其实就是后面会使用到RemoteContentProvider。</p>
<pre><code>public static Uri wrapperUri(LoadedPlugin loadedPlugin, Uri pluginUri) {
    String pkg = loadedPlugin.getPackageName();
    String pluginUriString = Uri.encode(pluginUri.toString());
    StringBuilder builder = new StringBuilder(RemoteContentProvider.getUri(loadedPlugin.getHostContext()));
    builder.append(&quot;/?plugin=&quot; + loadedPlugin.getLocation());
    builder.append(&quot;&amp;pkg=&quot; + pkg);
    builder.append(&quot;&amp;uri=&quot; + pluginUriString);
    Uri wrapperUri = Uri.parse(builder.toString());
    return wrapperUri;
}</code></pre><p>wrapperUri会拼接成</p>
<pre><code>content://com.libill.virtualapk.VirtualAPK.Provider/?plugin=/storage/emulated/0/Test.apk&amp;pkg=com.didi.virtualapk.demo&amp;uri=content%3A%2F%2Fcom.didi.virtualapk.demo.book.provider%2Fbook</code></pre><p>我们先看看pluginManager.loadPlugin(apk)时做了一些解释数据，并缓存起来。</p>
<pre><code>// Cache providers
Map&lt;String, ProviderInfo&gt; providers = new HashMap&lt;String, ProviderInfo&gt;();
Map&lt;ComponentName, ProviderInfo&gt; providerInfos = new HashMap&lt;ComponentName, ProviderInfo&gt;();
for (PackageParser.Provider provider : this.mPackage.providers) {
    providers.put(provider.info.authority, provider.info);
    providerInfos.put(provider.getComponentName(), provider.info);
}
this.mProviders = Collections.unmodifiableMap(providers);
this.mProviderInfos = Collections.unmodifiableMap(providerInfos);
this.mPackageInfo.providers = providerInfos.values().toArray(new ProviderInfo[providerInfos.size()]);</code></pre><p>当使用getContentResolver的query时，会通过IPC通信，调用acquireProvider获取IContentProvider的binder对象。而PluginContentResolver对acquireProvider等多个方法做了代理。</p>
<pre><code>@Override
protected IContentProvider acquireProvider(Context context, String auth) {
    if (mPluginManager.resolveContentProvider(auth, 0) != null) {
        return mPluginManager.getIContentProvider();
    }
    return super.acquireProvider(context, auth);
}</code></pre><p>在getIContentProvider方法，做了hook IContentProvider动作。</p>
<pre><code>public synchronized IContentProvider getIContentProvider() {
    if (mIContentProvider == null) {
        hookIContentProviderAsNeeded();
    }

    return mIContentProvider;
}</code></pre><p>使用了反射器对mProviderMap反射操作，获取mProviderMap来能获取到占坑的 Provider。对authority、mProvider做了setAccessible(true)，最终IContentProviderProxy.newInstance生成IContentProviderProxy对象。这里还使用了RemoteContentProvider包装Uri。</p>
<pre><code>protected void hookIContentProviderAsNeeded() {
    Uri uri = Uri.parse(RemoteContentProvider.getUri(mContext));
    mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null);
    try {
        Field authority = null;
        Field provider = null;
        ActivityThread activityThread = ActivityThread.currentActivityThread();
        Map providerMap = Reflector.with(activityThread).field(&quot;mProviderMap&quot;).get();
        Iterator iter = providerMap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Object key = entry.getKey();
            Object val = entry.getValue();
            String auth;
            if (key instanceof String) {
                auth = (String) key;
            } else {
                if (authority == null) {
                    authority = key.getClass().getDeclaredField(&quot;authority&quot;);
                    authority.setAccessible(true);
                }
                auth = (String) authority.get(key);
            }
            if (auth.equals(RemoteContentProvider.getAuthority(mContext))) {
                if (provider == null) {
                    provider = val.getClass().getDeclaredField(&quot;mProvider&quot;);
                    provider.setAccessible(true);
                }
                IContentProvider rawProvider = (IContentProvider) provider.get(val);
                IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider);
                mIContentProvider = proxy;
                Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider);
                break;
            }
        }
    } catch (Exception e) {
        Log.w(TAG, e);
    }
}</code></pre><p>IContentProvider使用了动态代理方式</p>
<pre><code>public static IContentProvider newInstance(Context context, IContentProvider iContentProvider) {
    return (IContentProvider) Proxy.newProxyInstance(iContentProvider.getClass().getClassLoader(),
            new Class[] { IContentProvider.class }, new IContentProviderProxy(context, iContentProvider));
}</code></pre><p>看看invoke方法，使用wrapperUri后直接调用method.invoke</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Log.v(TAG, method.toGenericString() + &quot; : &quot; + Arrays.toString(args));
    wrapperUri(method, args);

    try {
        return method.invoke(mBase, args);
    } catch (InvocationTargetException e) {
        throw e.getTargetException();
    }
}</code></pre><p>在RemoteContentProvider的getContentProvider可以看到加载和使用插件的ContentProvider。</p>
<pre><code>private ContentProvider getContentProvider(final Uri uri) {
    final PluginManager pluginManager = PluginManager.getInstance(getContext());
    Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI));
    final String auth = pluginUri.getAuthority();
    ContentProvider cachedProvider = sCachedProviders.get(auth);
    if (cachedProvider != null) {
        return cachedProvider;
    }

    synchronized (sCachedProviders) {
        LoadedPlugin plugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
        if (plugin == null) {
            try {
                pluginManager.loadPlugin(new File(uri.getQueryParameter(KEY_PLUGIN)));
            } catch (Exception e) {
                Log.w(TAG, e);
            }
        }

        final ProviderInfo providerInfo = pluginManager.resolveContentProvider(auth, 0);
        if (providerInfo != null) {
            RunUtil.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    try {
                        LoadedPlugin loadedPlugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));
                        ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance();
                        contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);
                        sCachedProviders.put(auth, contentProvider);
                    } catch (Exception e) {
                        Log.w(TAG, e);
                    }
                }
            }, true);
            return sCachedProviders.get(auth);
        }
    }

    return null;
}</code></pre><h3 id="八、支持插件中的Resources"><a href="#八、支持插件中的Resources" class="headerlink" title="八、支持插件中的Resources"></a>八、支持插件中的Resources</h3><p>资源的加载入口时加载插件时生成LoadedPlugin对象，这时开始加载资源。</p>
<pre><code>this.mResources = createResources(context, getPackageName(), apk);</code></pre><p>Constants.COMBINE_RESOURCES一直为true，直接进入ResourcesManager.createResources</p>
<pre><code>protected Resources createResources(Context context, String packageName, File apk) throws Exception {
    if (Constants.COMBINE_RESOURCES) {
        return ResourcesManager.createResources(context, packageName, apk);
    } else {
        Resources hostResources = context.getResources();
        AssetManager assetManager = createAssetManager(context, apk);
        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    }
}</code></pre><p>createResources加载资源后，用hook Resources一遍</p>
<pre><code>public static synchronized Resources createResources(Context hostContext, String packageName, File apk) throws Exception {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {
        return createResourcesForN(hostContext, packageName, apk);
    }

    Resources resources = ResourcesManager.createResourcesSimple(hostContext, apk.getAbsolutePath());
    ResourcesManager.hookResources(hostContext, resources);
    return resources;
}</code></pre><p>createResourcesForN是兼容N</p>
<pre><code>@TargetApi(Build.VERSION_CODES.N)
private static Resources createResourcesForN(Context context, String packageName, File apk) throws Exception {
    long startTime = System.currentTimeMillis();
    String newAssetPath = apk.getAbsolutePath();
    ApplicationInfo info = context.getApplicationInfo();
    String baseResDir = info.publicSourceDir;

    info.splitSourceDirs = append(info.splitSourceDirs, newAssetPath);
    LoadedApk loadedApk = Reflector.with(context).field(&quot;mPackageInfo&quot;).get();

    Reflector rLoadedApk = Reflector.with(loadedApk).field(&quot;mSplitResDirs&quot;);
    String[] splitResDirs = rLoadedApk.get();
    rLoadedApk.set(append(splitResDirs, newAssetPath));

    final android.app.ResourcesManager resourcesManager = android.app.ResourcesManager.getInstance();
    ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; originalMap = Reflector.with(resourcesManager).field(&quot;mResourceImpls&quot;).get();

    synchronized (resourcesManager) {
        HashMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; resolvedMap = new HashMap&lt;&gt;();

        if (Build.VERSION.SDK_INT &gt;= 28
            || (Build.VERSION.SDK_INT == 27 &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != 0)) { // P Preview
            ResourcesManagerCompatForP.resolveResourcesImplMap(originalMap, resolvedMap, context, loadedApk);

        } else {
            ResourcesManagerCompatForN.resolveResourcesImplMap(originalMap, resolvedMap, baseResDir, newAssetPath);
        }

        originalMap.clear();
        originalMap.putAll(resolvedMap);
    }

    android.app.ResourcesManager.getInstance().appendLibAssetForMainAssetPath(baseResDir, packageName + &quot;.vastub&quot;);

    Resources newResources = context.getResources();

    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : PluginManager.getInstance(context).getAllLoadedPlugins()) {
        plugin.updateResources(newResources);
    }

    Log.d(TAG, &quot;createResourcesForN cost time: +&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);
    return newResources;
}</code></pre><p>按照系统版本、厂家来兼容</p>
<pre><code>private static Resources createResourcesSimple(Context hostContext, String apk) throws Exception {
    Resources hostResources = hostContext.getResources();
    Resources newResources = null;
    AssetManager assetManager;
    Reflector reflector = Reflector.on(AssetManager.class).method(&quot;addAssetPath&quot;, String.class);
    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) {
        assetManager = AssetManager.class.newInstance();
        reflector.bind(assetManager);
        final int cookie1 = reflector.call(hostContext.getApplicationInfo().sourceDir);;
        if (cookie1 == 0) {
            throw new RuntimeException(&quot;createResources failed, can&apos;t addAssetPath for &quot; + hostContext.getApplicationInfo().sourceDir);
        }
    } else {
        assetManager = hostResources.getAssets();
        reflector.bind(assetManager);
    }
    final int cookie2 = reflector.call(apk);
    if (cookie2 == 0) {
        throw new RuntimeException(&quot;createResources failed, can&apos;t addAssetPath for &quot; + apk);
    }
    List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins();
    for (LoadedPlugin plugin : pluginList) {
        final int cookie3 = reflector.call(plugin.getLocation());
        if (cookie3 == 0) {
            throw new RuntimeException(&quot;createResources failed, can&apos;t addAssetPath for &quot; + plugin.getLocation());
        }
    }
    if (isMiUi(hostResources)) {
        newResources = MiUiResourcesCompat.createResources(hostResources, assetManager);
    } else if (isVivo(hostResources)) {
        newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager);
    } else if (isNubia(hostResources)) {
        newResources = NubiaResourcesCompat.createResources(hostResources, assetManager);
    } else if (isNotRawResources(hostResources)) {
        newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager);
    } else {
        // is raw android resources
        newResources = new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    }
    // lastly, sync all LoadedPlugin to newResources
    for (LoadedPlugin plugin : pluginList) {
        plugin.updateResources(newResources);
    }

    return newResources;
}</code></pre><h3 id="九、参考内容"><a href="#九、参考内容" class="headerlink" title="九、参考内容"></a>九、参考内容</h3><ol>
<li><a href="https://mp.weixin.qq.com/s/OSMI3bGQ5XyEBtsuzliJkw" target="_blank" rel="noopener">聊聊 VirtualAPK 插件化框架的开源</a>  </li>
<li><a href="https://mp.weixin.qq.com/s/O1W7OGkhFbJ4-NorBcOivQ" target="_blank" rel="noopener">VirtualAPK：滴滴 Android 插件化的实践之路</a>  </li>
<li><a href="https://github.com/didi/VirtualAPK/wiki" target="_blank" rel="noopener">VirtualApk GitHub Wiki官方入门文档</a>   </li>
<li><a href="https://mp.weixin.qq.com/s/CEXTMeQaOlubIwo1Lne8Ww" target="_blank" rel="noopener">VirtualAPK 资源加载分析</a>   </li>
<li><a href="https://mp.weixin.qq.com/s/eRQwaJUr9y93ANEIfjktnQ" target="_blank" rel="noopener">Android插件化快速入门与实例解析（VirtualApk）</a>  </li>
<li><a href="https://mp.weixin.qq.com/s/Z-Tt6IjgQWpsqmlcDmlWmQ" target="_blank" rel="noopener">深度 | 滴滴插件化方案 VirtualApk 源码解析</a>  </li>
<li><a href="https://mp.weixin.qq.com/s/TGFsjZvU_qRZbWeNbqW1kQ" target="_blank" rel="noopener">插件化探索，滴滴开源框架VirtualAPK的深入分析</a>  </li>
<li>图书推荐《Android插件化开发指南》</li>
</ol>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/插件化/" rel="tag"># 插件化</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/09/android-touch-event/" rel="next" title="一文读懂 Android TouchEvent 事件分发、拦截、处理过程">
                  <i class="fa fa-chevron-left"></i> 一文读懂 Android TouchEvent 事件分发、拦截、处理过程
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、从代码入口分析"><span class="nav-number">1.</span> <span class="nav-text">一、从代码入口分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、hookInstrumentationAndHandler"><span class="nav-number">2.</span> <span class="nav-text">二、hookInstrumentationAndHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、hookSystemServices"><span class="nav-number">3.</span> <span class="nav-text">三、hookSystemServices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、hook-DataBindingUtil"><span class="nav-number">4.</span> <span class="nav-text">三、hook DataBindingUtil</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、支持插件中的Activity"><span class="nav-number">5.</span> <span class="nav-text">四、支持插件中的Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、支持插件中的Service"><span class="nav-number">6.</span> <span class="nav-text">五、支持插件中的Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、支持插件中的BroadcastReceiver"><span class="nav-number">7.</span> <span class="nav-text">六、支持插件中的BroadcastReceiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、支持插件中的ContentProvider"><span class="nav-number">8.</span> <span class="nav-text">七、支持插件中的ContentProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、支持插件中的Resources"><span class="nav-number">9.</span> <span class="nav-text">八、支持插件中的Resources</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、参考内容"><span class="nav-number">10.</span> <span class="nav-text">九、参考内容</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">libill</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">libill</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>










  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "500696841");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>


        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>





















  

  

  

</body>
</html>
